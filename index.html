<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Team Builder Pro - Team Building & Games Platform</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='50' font-size='50'%3E%F0%9F%8E%AF%3C/text%3E%3C/svg%3E">
<link href="https://fonts.googleapis.com/css2?family=Fraunces:wght@600;800&family=Outfit:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #07070d;
    --surface: rgba(255,255,255,0.035);
    --surface-solid: #111118;
    --surface-2: rgba(255,255,255,0.06);
    --border: rgba(255,255,255,0.07);
    --border-hover: rgba(255,255,255,0.14);
    --text: #ece9e1;
    --text-dim: #7d7a8a;
    --text-mid: #a9a6b5;
    --accent: #00d2d3;
    --accent-2: #c56cf0;
    --success: #00d26a;
    --warning: #feca57;
    --danger: #ff4060;
    --radius: 20px;
  }

  * { margin:0; padding:0; box-sizing:border-box; }

  body {
    font-family: 'Outfit', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
  }

  .atmosphere {
    position: fixed; inset: 0; z-index: 0; pointer-events: none;
  }
  .atmosphere .mesh {
    position: absolute; border-radius: 50%; filter: blur(140px); opacity: 0.1;
    animation: drift 25s ease-in-out infinite;
  }
  .atmosphere .mesh:nth-child(1) { width: 600px; height: 600px; background: var(--accent); top: -15%; left: -10%; }
  .atmosphere .mesh:nth-child(2) { width: 500px; height: 500px; background: var(--accent-2); bottom: -15%; right: -10%; animation-delay: -9s; }
  .atmosphere .mesh:nth-child(3) { width: 400px; height: 400px; background: var(--warning); top: 50%; left: 40%; animation-delay: -16s; opacity: 0.06; }
  
  @keyframes drift {
    0%,100% { transform: translate(0,0) scale(1); }
    25% { transform: translate(40px,-30px) scale(1.08); }
    50% { transform: translate(-20px,40px) scale(0.95); }
    75% { transform: translate(30px,20px) scale(1.03); }
  }

  .grain {
    position: fixed; inset: 0; z-index: 9998; pointer-events: none; opacity: 0.025;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
  }

  #particles { position: fixed; inset: 0; z-index: 0; pointer-events: none; }

  .app {
    position: relative; z-index: 1;
    max-width: 1200px; margin: 0 auto; padding: 20px;
    min-height: 100vh;
  }

  @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
  @keyframes shimmer { 0% { background-position: -200% center; } 100% { background-position: 200% center; } }
  @keyframes pulse { 0%,100% { transform:scale(1); } 50% { transform:scale(1.05); } }

  .header {
    text-align: center; padding: 40px 0 30px;
  }

  .logo {
    font-family: 'Fraunces', serif; font-weight: 800;
    font-size: clamp(2.5rem, 6vw, 3.5rem); line-height: 1;
    background: linear-gradient(135deg, var(--text) 0%, var(--warning) 40%, var(--accent) 70%, var(--accent-2) 100%);
    background-size: 200% auto;
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    animation: shimmer 6s linear infinite;
    margin-bottom: 10px;
  }

  .tagline {
    color: var(--text-dim); font-size: 1rem;
  }

  .player-card {
    background: var(--surface-solid);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 30px;
    margin-bottom: 30px;
    display: flex;
    align-items: center;
    gap: 20px;
  }

  .avatar-circle {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--accent), var(--accent-2));
    display: grid;
    place-items: center;
    font-size: 2.5rem;
    flex-shrink: 0;
  }

  .player-info {
    flex: 1;
  }

  .player-name {
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 5px;
  }

  .player-stats {
    display: flex;
    gap: 20px;
    color: var(--text-dim);
    font-size: 0.9rem;
  }

  .stat {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .level-badge {
    background: var(--accent);
    color: var(--bg);
    padding: 6px 16px;
    border-radius: 20px;
    font-weight: 700;
    font-size: 0.9rem;
  }

  .btn-primary {
    width: 100%;
    padding: 16px;
    border: none;
    border-radius: 12px;
    font-family: 'Outfit', sans-serif;
    font-size: 1rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--accent-2));
    color: var(--bg);
    cursor: pointer;
    transition: all 0.3s;
  }

  .btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 40px rgba(0,210,211,0.2);
  }

  .btn-secondary {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 12px 24px;
    border-radius: 10px;
    font-family: 'Outfit', sans-serif;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s;
  }

  .btn-secondary:hover {
    border-color: var(--accent);
  }

  .grid-2 {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin: 30px 0;
  }

  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 30px;
    cursor: pointer;
    transition: all 0.3s;
    text-align: center;
  }
  
  .tile-btn {
    font: inherit;
    color: inherit;
    text-align: inherit;
    background: none;
  }

  button.card,
  button.kahoot-answer,
  button.tile-btn {
    font-family: 'Outfit', sans-serif;
  }

  button.card {
    width: 100%;
  }

  button.card:focus-visible,
  button.kahoot-answer:focus-visible,
  button.tile-btn:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  button[data-action="select-avatar"]:hover,
  button[data-action="select-edit-avatar"]:hover {
    border-color: var(--accent) !important;
  }

  button[data-action="select-avatar"].selected,
  button[data-action="select-edit-avatar"].selected {
    border-color: var(--accent) !important;
  }

  .tile-btn:hover:not(:disabled) {
    border-color: var(--border-hover) !important;
    transform: translateY(-2px);
  }

  .tile-btn:disabled:hover {
    transform: none;
  }

  .card:hover {
    border-color: var(--accent);
    transform: translateY(-4px);
  }

  .card-icon {
    font-size: 3rem;
    margin-bottom: 15px;
  }

  .card-title {
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--text);
    margin-bottom: 8px;
  }

  .card-desc {
    color: var(--text-dim);
    font-size: 0.9rem;
  }

  .form-container {
    max-width: 500px;
    margin: 0 auto;
    background: var(--surface-solid);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 40px;
  }

  .form-group {
    margin-bottom: 20px;
  }

  .form-label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
  }

  .form-input {
    width: 100%;
    background: var(--surface-2);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 12px 16px;
    border-radius: 10px;
    font-size: 1rem;
    font-family: 'Outfit', sans-serif;
    outline: none;
  }

  .form-input:focus {
    border-color: var(--accent);
  }

  .presentation-toggle {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    background: var(--surface-solid);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 10px 20px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.3s;
  }

  .presentation-toggle:hover {
    border-color: var(--accent);
  }

  .presentation-mode .app {
    max-width: 100%;
    padding: 40px;
  }

  .presentation-mode .logo {
    font-size: 4rem;
  }

  .presentation-mode .question-text {
    font-size: 3rem;
  }

  .kahoot-timer {
    width: 120px;
    height: 120px;
    margin: 0 auto 30px;
    position: relative;
  }

  .timer-circle {
    width: 100%;
    height: 100%;
    transform: rotate(-90deg);
  }

  .timer-bg {
    fill: none;
    stroke: var(--surface-2);
    stroke-width: 10;
  }

  .timer-progress {
    fill: none;
    stroke: var(--accent);
    stroke-width: 10;
    stroke-linecap: round;
    transition: stroke-dashoffset 0.1s linear;
  }

  .timer-progress.warning {
    stroke: var(--danger);
  }

  .timer-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2rem;
    font-weight: 700;
    font-family: 'IBM Plex Mono', monospace;
  }

  .kahoot-answer {
    padding: 24px;
    border-radius: 16px;
    border: 3px solid;
    font-size: 1.2rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s;
    text-align: center;
    position: relative;
    overflow: hidden;
  }

  .kahoot-answer:active:not(.disabled) {
    transform: scale(0.97);
  }

  .kahoot-answer.disabled {
    cursor: not-allowed;
    opacity: 0.6;
  }

  .kahoot-answer.selected {
    transform: scale(0.95);
  }

  .kahoot-selected-badge {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: var(--success);
    color: var(--bg);
    display: grid;
    place-items: center;
    font-size: 0.95rem;
    font-weight: 700;
    box-shadow: 0 4px 14px rgba(0, 210, 106, 0.35);
  }

  .kahoot-answer.correct {
    background: var(--success);
    border-color: var(--success);
    animation: pulse 0.5s ease-in-out;
  }

  .kahoot-answer.wrong {
    opacity: 0.3;
  }

  .kahoot-red { background: #e21b3c; border-color: #e21b3c; color: white; }
  .kahoot-blue { background: #1368ce; border-color: #1368ce; color: white; }
  .kahoot-yellow { background: #d89e00; border-color: #d89e00; color: white; }
  .kahoot-green { background: #26890c; border-color: #26890c; color: white; }

  .podium {
    display: flex;
    align-items: flex-end;
    justify-content: center;
    gap: 20px;
    margin: 40px 0;
  }

  .podium-place {
    background: var(--surface-solid);
    border: 2px solid var(--border);
    border-radius: 16px;
    padding: 20px;
    text-align: center;
    min-width: 120px;
  }

  .podium-place.first {
    border-color: #ffd700;
    transform: translateY(-20px);
  }

  .podium-place.second {
    border-color: #c0c0c0;
  }

  .podium-place.third {
    border-color: #cd7f32;
  }

  .podium-medal {
    font-size: 3rem;
    margin-bottom: 10px;
  }

  @keyframes confettiFall {
    0% {
      transform: translate3d(0, -12vh, 0) rotate(0deg);
      opacity: 0;
    }
    10% {
      opacity: 1;
    }
    100% {
      transform: translate3d(var(--confetti-drift, 0px), 110vh, 0) rotate(680deg);
      opacity: 0;
    }
  }

  .trivia-confetti {
    position: fixed;
    inset: 0;
    z-index: 3;
    pointer-events: none;
    overflow: hidden;
  }

  .trivia-confetti-piece {
    position: absolute;
    top: -12vh;
    width: 10px;
    height: 18px;
    border-radius: 2px;
    animation-name: confettiFall;
    animation-timing-function: linear;
    animation-iteration-count: 1;
    animation-fill-mode: forwards;
    will-change: transform, opacity;
  }

  @media (prefers-reduced-motion: reduce) {
    .trivia-confetti {
      display: none;
    }
  }

  .wordle-grid {
    display: grid;
    gap: 8px;
    max-width: 350px;
    margin: 30px auto;
  }

  .wordle-row {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 8px;
  }

  .wordle-cell {
    width: 60px;
    height: 60px;
    border: 2px solid var(--border);
    border-radius: 6px;
    display: grid;
    place-items: center;
    font-size: 2rem;
    font-weight: 700;
    text-transform: uppercase;
    background: var(--surface-2);
  }

  .wordle-cell.correct {
    background: var(--success);
    border-color: var(--success);
    color: var(--bg);
  }

  .wordle-cell.present {
    background: var(--warning);
    border-color: var(--warning);
    color: var(--bg);
  }

  .wordle-cell.absent {
    background: var(--surface);
    opacity: 0.5;
  }

  .host-wordle-cell-input {
    width: 100%;
    height: 100%;
    border: none;
    background: transparent;
    color: var(--text);
    text-transform: uppercase;
    text-align: center;
    font: inherit;
    font-weight: 700;
    outline: none;
  }

  .word-chain-shell {
    max-width: 820px;
    margin: 0 auto 20px;
    background: var(--surface-solid);
    border: 1px solid var(--border);
    border-radius: 18px;
    padding: 20px;
    color: var(--text);
  }

  .word-chain-help {
    font-size: 0.92rem;
    color: var(--text-dim);
    margin-bottom: 8px;
  }

  .word-chain-board {
    display: grid;
    gap: 8px;
    margin-top: 14px;
  }

  .word-chain-board-row {
    display: grid;
    grid-template-columns: minmax(0, 1fr) auto;
    gap: 8px;
    align-items: center;
  }

  .word-chain-row {
    display: grid;
    grid-template-columns: repeat(9, 1fr);
    gap: 8px;
    align-items: center;
  }

  .word-chain-cell {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: 8px;
    border: 2px solid var(--border);
    display: grid;
    place-items: center;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 0.2px;
    font-size: 1.02rem;
    background: var(--surface-2);
    color: var(--text);
  }

  .word-chain-cell.blank {
    background: rgba(255,255,255,0.02);
    border-color: rgba(255,255,255,0.05);
    color: transparent;
  }

  .word-chain-cell.top-anchor {
    background: var(--warning);
    border-color: var(--warning);
    color: var(--bg);
  }

  .word-chain-cell.bottom-anchor {
    background: var(--success);
    border-color: var(--success);
    color: var(--bg);
  }

  .word-chain-cell.solved {
    background: var(--success);
    border-color: var(--success);
    color: var(--bg);
  }

  .word-chain-score-bubble {
    padding: 2px 8px;
    border-radius: 999px;
    background: var(--success);
    color: var(--bg);
    font-size: 0.72rem;
    font-weight: 800;
    line-height: 1.4;
    white-space: nowrap;
  }

  @keyframes wordChainFocusCue {
    0% { box-shadow: 0 0 0 0 rgba(0, 210, 211, 0.35); }
    100% { box-shadow: 0 0 0 8px rgba(0, 210, 211, 0); }
  }

  .word-chain-letter-input {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: 8px;
    border: 2px solid var(--border);
    background: var(--surface-2);
    color: var(--text);
    text-align: center;
    font-size: 1.02rem;
    font-weight: 800;
    text-transform: uppercase;
    padding: 0;
    outline: none;
  }

  .word-chain-letter-input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(0, 210, 211, 0.14);
  }

  .word-chain-letter-input.autofocus-cue {
    animation: wordChainFocusCue 380ms ease-out;
  }

  .word-chain-status {
    margin-top: 12px;
    padding: 10px;
    border-radius: 10px;
    background: var(--surface-2);
    border: 1px solid var(--border);
    color: var(--text-mid);
  }

  .emoji-charades-prompt {
    font-size: clamp(2.2rem, 7vw, 4rem);
    letter-spacing: 6px;
    line-height: 1.2;
  }

  .emoji-charades-guess-row {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 10px;
    margin-top: 14px;
  }

  .emoji-charades-chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border-radius: 999px;
    font-size: 0.8rem;
    font-weight: 700;
    padding: 4px 10px;
  }

  .brain-board {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 14px;
    margin-top: 18px;
  }

  .brain-lane {
    background: var(--surface-solid);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 14px;
    min-height: 220px;
  }

  .brain-lane-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    font-weight: 700;
  }

  .brain-note {
    background: #fef3a7;
    color: #1f2937;
    border: 1px solid rgba(0,0,0,0.18);
    border-radius: 10px;
    padding: 10px;
    margin-bottom: 8px;
    cursor: grab;
  }

  .brain-lane-notes {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 8px;
  }

  .brain-note:active {
    cursor: grabbing;
  }

  .brain-note-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
    font-size: 0.78rem;
    color: #334155;
  }

  .brain-vote-btn {
    border: 1px solid rgba(0,0,0,0.2);
    border-radius: 999px;
    background: #fff;
    color: #0f172a;
    padding: 4px 10px;
    font-size: 0.78rem;
    font-weight: 700;
    cursor: pointer;
  }

  .brain-vote-btn.voted {
    background: #dcfce7;
    border-color: #16a34a;
    color: #166534;
  }

  .brain-note-controls {
    display: flex;
    gap: 6px;
    margin-top: 8px;
  }

  .brain-note-controls .btn-secondary {
    padding: 4px 8px;
    font-size: 0.78rem;
  }

  .host-tabs {
    display: flex;
    gap: 8px;
    margin-bottom: 14px;
    flex-wrap: wrap;
  }

  .host-tab-btn {
    border: 1px solid var(--border);
    background: var(--surface-2);
    color: var(--text-mid);
    border-radius: 999px;
    padding: 8px 14px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
  }

  .host-tab-btn.active {
    border-color: var(--accent);
    background: rgba(0, 210, 211, 0.12);
    color: var(--text);
  }

  .host-tab-panel[hidden] {
    display: none !important;
  }

  @media (max-width: 900px) {
    .brain-board {
      grid-template-columns: 1fr;
    }

    .brain-lane-notes {
      grid-template-columns: 1fr;
    }
  }

  .key-btn {
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface-2);
    color: var(--text);
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    padding: 14px 10px;
    min-width: 40px;
    transition: all 0.2s;
  }

  .key-btn:hover {
    background: var(--accent);
    border-color: var(--accent);
  }

  .key-btn.wide {
    padding: 14px 20px;
    min-width: 80px;
  }

  .key-btn.correct { background: var(--success); border-color: var(--success); }
  .key-btn.present { background: var(--warning); border-color: var(--warning); }
  .key-btn.absent { opacity: 0.3; }

  .reaction-bar {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 8px;
    margin: 0 0 16px;
  }

  .reaction-btn {
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 999px;
    padding: 8px 12px;
    font-size: 1.2rem;
    cursor: pointer;
    transition: transform 0.12s ease, border-color 0.2s ease;
  }

  .reaction-btn:hover {
    border-color: var(--accent);
  }

  .reaction-btn:active {
    transform: scale(0.92);
  }

  .reaction-stream {
    min-height: 36px;
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 6px;
    margin-bottom: 12px;
  }

  .reaction-pill {
    background: rgba(255,255,255,0.06);
    border: 1px solid var(--border);
    border-radius: 999px;
    padding: 4px 10px;
    animation: riseFade 2.2s ease forwards;
  }

  @keyframes riseFade {
    from { opacity: 0; transform: translateY(8px); }
    20% { opacity: 1; }
    to { opacity: 0; transform: translateY(-8px); }
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  @media (max-width: 768px) {
    .grid-2 {
      grid-template-columns: 1fr;
    }
    
      .qr-grid {
        grid-template-columns: 1fr !important;
        align-items: stretch !important;
      }
      .qr-grid > div {
        margin-bottom: 18px;
      }
      .qr-grid img {
        margin-left: auto;
        margin-right: auto;
      }
    .kahoot-answer {
      padding: 18px;
      font-size: 1rem;
    }
  }
</style>
</head>
<body>
<div class="atmosphere"><div class="mesh"></div><div class="mesh"></div><div class="mesh"></div></div>
<div class="grain"></div>
<canvas id="particles"></canvas>

<div class="app" id="app"></div>

<script src="https://cdn.socket.io/4.8.1/socket.io.min.js" crossorigin="anonymous"></script>
<script>
// Particle system
const canvas = document.getElementById('particles');
const ctx = canvas.getContext('2d');
let particles = [];
function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
for (let i = 0; i < 40; i++) {
  particles.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    vx: (Math.random() - 0.5) * 0.3,
    vy: (Math.random() - 0.5) * 0.3,
    r: Math.random() * 1.5 + 0.3,
    a: Math.random() * 0.3 + 0.05
  });
}
function drawParticles() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  particles.forEach(p => {
    p.x += p.vx; p.y += p.vy;
    if (p.x < 0) p.x = canvas.width;
    if (p.x > canvas.width) p.x = 0;
    if (p.y < 0) p.y = canvas.height;
    if (p.y > canvas.height) p.y = 0;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${p.a})`;
    ctx.fill();
  });
  requestAnimationFrame(drawParticles);
}
drawParticles();

const AVATAR_OPTIONS = [
  'ğŸ˜€','ğŸ˜','ğŸ¤“','ğŸ§ ','ğŸš€','ğŸ”¥','âš¡','ğŸ’¡','ğŸ¯','ğŸ†',
  'ğŸ‘¨â€ğŸ’¼','ğŸ‘©â€ğŸ’¼','ğŸ§‘â€ğŸ’»','ğŸ‘¨â€ğŸ¨','ğŸ‘©â€ğŸ”¬','ğŸ§‘â€ğŸš€',
  'ğŸ‘¨â€ğŸ«','ğŸ‘©â€âš•ï¸','ğŸ§‘â€ğŸ³','ğŸ‘¨â€ğŸŒ¾','ğŸ‘©â€ğŸ¤','ğŸ§‘â€âœˆï¸',
  'ğŸ‘¨â€ğŸ“','ğŸ‘©â€ğŸš’','ğŸ§‘â€âš–ï¸','ğŸ‘¨â€ğŸ”§','ğŸ§‘â€ğŸ”¬','ğŸ§‘â€ğŸ«',
  'ğŸ§‘â€ğŸš’','ğŸ§‘â€ğŸ¨','ğŸ§‘â€âš•ï¸','ğŸ§‘â€ğŸ”§','ğŸ§‘â€ğŸ’¼','ğŸ§‘â€ğŸŒ¾',
  'ğŸ¼','ğŸ¦Š','ğŸ¯','ğŸ¦','ğŸ¸','ğŸ¦„','ğŸ™','ğŸ§','ğŸ¨','ğŸ¦‰',
  'ğŸ•','ğŸ©','ğŸŸ','â˜•','ğŸ®','ğŸ§','ğŸ“š','ğŸ§©','ğŸŒŸ','ğŸ‰'
];

const LIGHTNING_REACTIONS = ['ğŸ‘','ğŸ‘','ğŸ”¥','ğŸ˜„','ğŸ¤¯','ğŸ‰','âš¡','ğŸ’¯'];

function getRandomAvatar() {
  return AVATAR_OPTIONS[Math.floor(Math.random() * AVATAR_OPTIONS.length)] || 'ğŸ˜€';
}

function safeParseJson(value) {
  try {
    return JSON.parse(value);
  } catch (e) {
    console.error('Invalid JSON payload:', e.message);
    return null;
  }
}

function normalizeName(name) {
  return name.replace(/\s+/g, ' ').trim().slice(0, 32);
}

function normalizeWord(word) {
  return (word || '').toUpperCase().replace(/[^A-Z]/g, '').slice(0, 5);
}

function normalizeChainWord(word) {
  return (word || '').toUpperCase().replace(/[^A-Z]/g, '').slice(0, 16);
}

function normalizeCharadesAnswer(value) {
  return String(value || '')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .slice(0, 80);
}

function normalizeEmoji(value) {
  return String(value || '').trim().slice(0, 8);
}

function normalizeTopic(value) {
  return String(value || '').replace(/\s+/g, ' ').trim().slice(0, 80);
}

function normalizeRoomCode(value) {
  return String(value || '').toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 6);
}

function normalizeTriviaOption(value) {
  const raw = String(value || '').trim();
  return raw
    .replace(/^\s*[A-D]\s*[:\)\.\-]\s*/i, '')
    .replace(/^\s*[A-D]\s+/i, '')
    .trim();
}

function normalizeAnswerIndex(value) {
  if (typeof value === 'number' && Number.isInteger(value)) return value;
  const text = String(value || '').trim().toUpperCase();
  const asNumber = Number.parseInt(text, 10);
  if (!Number.isNaN(asNumber)) return asNumber;
  if (/^[A-D]$/.test(text)) return text.charCodeAt(0) - 65;
  return Number.NaN;
}

function escapeHtml(value) {
  return String(value ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function extractFirstJson(text) {
  if (!text) return null;
  const trimmed = String(text).trim();
  if (trimmed.startsWith('[') || trimmed.startsWith('{')) return trimmed;
  const start = trimmed.indexOf('[');
  const end = trimmed.lastIndexOf(']');
  if (start >= 0 && end > start) return trimmed.slice(start, end + 1);
  return null;
}

function validateAIQuestions(items) {
  if (!Array.isArray(items)) return [];
  return items
    .filter(item => item && typeof item === 'object')
    .map(item => {
      const q = String(item.q || '').trim();
      const opts = Array.isArray(item.opts) ? item.opts.map(v => normalizeTriviaOption(v)) : [];
      const ans = normalizeAnswerIndex(item.ans);
      if (!q || opts.length !== 4 || opts.some(v => !v) || Number.isNaN(ans) || ans < 0 || ans > 3) return null;
      return { q, opts, ans };
    })
    .filter(Boolean);
}

function validateAIIcebreakerQuestions(items) {
  if (!Array.isArray(items)) return [];
  return items
    .map(item => String(item ?? '').replace(/\s+/g, ' ').trim())
    .filter(Boolean)
    .map(text => text.slice(0, 220));
}

function validateAIPulseQuestions(items) {
  if (!Array.isArray(items)) return [];
  return items
    .filter(item => item && typeof item === 'object')
    .map(item => {
      const q = String(item.q || '').replace(/\s+/g, ' ').trim().slice(0, 220);
      const opts = Array.isArray(item.opts)
        ? item.opts.map(opt => String(opt || '').replace(/\s+/g, ' ').trim()).filter(Boolean).slice(0, 4)
        : [];
      if (!q || opts.length !== 4) return null;
      return { q, opts };
    })
    .filter(Boolean);
}

function validateAIValues(items) {
  if (!Array.isArray(items)) return [];
  return items
    .filter(item => item && typeof item === 'object')
    .map(item => {
      const name = String(item.name || '').replace(/\s+/g, ' ').trim().slice(0, 36);
      const icon = normalizeEmoji(item.icon || 'â­');
      if (!name) return null;
      return { name, icon: icon || 'â­' };
    })
    .filter(Boolean);
}

function validateAIWordleWords(items) {
  if (!Array.isArray(items)) return [];
  const unique = new Set();
  const out = [];
  items.forEach(item => {
    const word = normalizeWord(String(item || ''));
    if (word.length !== 5 || unique.has(word)) return;
    unique.add(word);
    out.push(word);
  });
  return out;
}

function validateAIWordChainPuzzles(items) {
  if (!Array.isArray(items)) return [];
  return items
    .filter(item => item && typeof item === 'object')
    .map((item, idx) => {
      const title = String(item.title || `Chain AI ${idx + 1}`).replace(/\s+/g, ' ').trim().slice(0, 40) || `Chain AI ${idx + 1}`;
      const words = Array.isArray(item.words)
        ? item.words.map(word => String(word || '').toUpperCase().replace(/[^A-Z]/g, '').slice(0, 9)).filter(Boolean).slice(0, 8)
        : [];
      if (words.length !== 8) return null;
      return { title, words };
    })
    .filter(Boolean);
}

function validateAIEmojiCharades(items) {
  if (!Array.isArray(items)) return [];
  return items
    .filter(item => item && typeof item === 'object')
    .map(item => {
      const emojis = String(item.emojis || item.emoji || '').trim().slice(0, 40);
      const answer = String(item.answer || '').replace(/\s+/g, ' ').trim().slice(0, 60);
      if (!emojis || !answer) return null;
      return { emojis, answer };
    })
    .filter(Boolean);
}

function validateAIBrainstormNotes(items) {
  if (!Array.isArray(items)) return [];
  const allowedLanes = new Set(['start', 'stop', 'improve', 'create']);
  return items
    .filter(item => item && typeof item === 'object')
    .map(item => {
      const text = String(item.text || '').replace(/\s+/g, ' ').trim().slice(0, 200);
      const laneRaw = String(item.lane || 'start').toLowerCase().trim();
      const lane = allowedLanes.has(laneRaw) ? laneRaw : 'start';
      if (!text) return null;
      return { text, lane };
    })
    .filter(Boolean);
}

function coerceAIArrayPayload(payload) {
  if (Array.isArray(payload)) return payload;
  if (payload && typeof payload === 'object') {
    if (Array.isArray(payload.items)) return payload.items;
    if (Array.isArray(payload.data)) return payload.data;
    if (Array.isArray(payload.results)) return payload.results;
  }
  return [];
}

function buildShuffledQuestionOrder(total) {
  const order = Array.from({ length: total }, (_, i) => i);
  for (let i = order.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [order[i], order[j]] = [order[j], order[i]];
  }
  return order;
}

function randomAlphaNum(length) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  if (!window.crypto?.getRandomValues) {
    return Array.from({ length }, () => chars[Math.floor(Math.random() * chars.length)]).join('');
  }
  const bytes = new Uint8Array(length);
  crypto.getRandomValues(bytes);
  return Array.from(bytes, b => chars[b % chars.length]).join('');
}

function getFeedbackUserToken() {
  let token = localStorage.getItem(FEEDBACK_USER_TOKEN_KEY) || '';
  if (!token) {
    token = `u_${randomAlphaNum(18)}`;
    localStorage.setItem(FEEDBACK_USER_TOKEN_KEY, token);
  }
  return token;
}

function applyBranding(config) {
  const branding = config?.branding || {};
  const preferences = config?.preferences || {};
  const appName = String(branding.appName || APP.branding.appName).trim();
  const tagline = String(branding.tagline || APP.branding.tagline).trim();
  const accent = /^#[0-9a-fA-F]{6}$/.test(String(branding.accent || '').trim())
    ? String(branding.accent).trim()
    : APP.branding.accent;

  APP.branding = {
    appName: appName || APP.branding.appName,
    tagline: tagline || APP.branding.tagline,
    accent
  };
  APP.preferences = {
    ...APP.preferences,
    ...preferences
  };
  document.documentElement.style.setProperty('--accent', APP.branding.accent);
}

async function apiRequest(path, options = {}) {
  const headers = { ...(options.headers || {}) };
  if (options.withUserToken) headers['x-user-token'] = getFeedbackUserToken();
  if (options.adminToken) headers['x-admin-token'] = options.adminToken;
  if (options.body && !headers['Content-Type']) headers['Content-Type'] = 'application/json';

  const response = await fetch(`${API_BASE_URL}${path}`, {
    method: options.method || 'GET',
    headers,
    body: options.body ? JSON.stringify(options.body) : undefined
  });
  const data = await response.json().catch(() => ({}));
  if (!response.ok || data?.ok === false) {
    throw new Error(data?.error || `Request failed: ${response.status}`);
  }
  return data;
}

function getDefaultRoomHostSettings() {
  return {
    autoRevealLightning: true,
    allowAnswerChanges: true,
    dynamicScoring: true,
    enableAIGenerator: true
  };
}

function getRoomHostSettings(room) {
  return { ...getDefaultRoomHostSettings(), ...(room?.hostSettings || {}) };
}

function getDefaultHostLocalConfig() {
  return {
    aiEndpoint: window.AI_QUESTION_ENDPOINT || 'https://api.openai.com/v1/chat/completions',
    aiModel: window.AI_QUESTION_MODEL || 'gpt-4o-mini',
    aiDefaultActivity: 'lightning-trivia',
    aiDefaultDifficulty: 'mixed',
    aiDefaultCount: 8,
    aiApiKey: localStorage.getItem('ai-question-api-key') || ''
  };
}

function loadHostLocalConfig() {
  const defaults = getDefaultHostLocalConfig();
  const stored = safeParseJson(localStorage.getItem('host-local-config') || '');
  if (!stored || typeof stored !== 'object') return defaults;
  const merged = { ...defaults, ...stored };
  const validActivities = new Set([
    'lightning-trivia',
    'regular-trivia',
    'icebreaker',
    'pulse-check',
    'values-vote',
    'wordle',
    'word-chain',
    'brainstorm-canvas'
  ]);
  if (!validActivities.has(merged.aiDefaultActivity)) {
    merged.aiDefaultActivity = defaults.aiDefaultActivity;
  }
  return merged;
}

function saveHostLocalConfig(config) {
  localStorage.setItem('host-local-config', JSON.stringify(config));
}

const SOCKET_SERVER_URL = window.SOCKET_SERVER_URL || localStorage.getItem('socket-server-url') || window.location.origin;
const API_BASE_URL = window.APP_API_BASE_URL || window.location.origin;
const ENABLE_PRESENTATION_SHARE = false;
let socketClient = null;
let socketRealtimeBound = false;
let socketRoomKey = null;
const FEEDBACK_USER_TOKEN_KEY = 'feedback-user-token';

// Configure these for cross-device realtime sync via Supabase.
// You can also set window.SUPABASE_URL / window.SUPABASE_ANON_KEY before this script loads.
const SUPABASE_URL = window.SUPABASE_URL || '';
const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || '';

let supabaseClient = null;

function isSupabaseConfigured() {
  return Boolean(SUPABASE_URL && SUPABASE_ANON_KEY && window.supabase?.createClient);
}

function isValidSharedKey(key) {
  return /^room:[A-Z0-9]{6}$/.test(key || '');
}

function isSocketConfigured() {
  return Boolean(window.io);
}

function socketEmitAck(eventName, payload, timeoutMs = 1500) {
  return new Promise((resolve, reject) => {
    if (!socketClient || !socketClient.connected) {
      reject(new Error('Socket unavailable'));
      return;
    }
    const timeout = setTimeout(() => reject(new Error('Socket timeout')), timeoutMs);
    socketClient.emit(eventName, payload, response => {
      clearTimeout(timeout);
      if (!response || response.ok === false) {
        reject(new Error(response?.error || `Socket ${eventName} failed`));
        return;
      }
      resolve(response);
    });
  });
}

function waitForSocketConnection(timeoutMs = 1200) {
  return new Promise(resolve => {
    if (!socketClient) {
      resolve(false);
      return;
    }
    if (socketClient.connected) {
      resolve(true);
      return;
    }
    const done = connected => {
      clearTimeout(timer);
      socketClient.off('connect', onConnect);
      resolve(connected);
    };
    const onConnect = () => done(true);
    const timer = setTimeout(() => done(false), timeoutMs);
    socketClient.on('connect', onConnect);
  });
}

async function getSocketClient() {
  if (!isSocketConfigured()) return null;
  if (!socketClient) {
    socketClient = window.io(SOCKET_SERVER_URL, {
      transports: ['websocket', 'polling']
    });
    socketClient.on('connect', () => {
      if (APP.roomCode) {
        socketRoomKey = `room:${APP.roomCode}`;
        socketClient.emit('room:subscribe', socketRoomKey);
        roomRealtimeEnabled = true;
      }
    });
    socketClient.on('disconnect', () => {
      roomRealtimeEnabled = false;
    });
  }
  if (!socketRealtimeBound) {
    socketClient.on('shared:update', payload => {
      const key = payload?.key;
      const value = payload?.value;
      if (!key || key !== socketRoomKey || !APP.roomCode) return;
      const room = safeParseJson(value);
      if (room) {
        APP.room = room;
        roomRealtimeEnabled = true;
        render();
      }
    });
    socketRealtimeBound = true;
  }
  return socketClient;
}

async function getSupabaseClient() {
  if (!isSupabaseConfigured()) return null;
  if (!supabaseClient) {
    supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  }
  return supabaseClient;
}

// Storage API wrapper
const Storage = {
  get: async function(key, shared = false) {
    try {
      if (shared) {
        if (!isValidSharedKey(key)) return null;
        const socket = await getSocketClient();
        if (socket && (socket.connected || await waitForSocketConnection())) {
          const response = await socketEmitAck('shared:get', { key });
          return response.value === null || response.value === undefined ? null : { value: response.value };
        }
        const client = await getSupabaseClient();
        if (client) {
          const { data, error } = await client
            .from('shared_state')
            .select('value')
            .eq('key', key)
            .maybeSingle();
          if (error) throw error;
          return data ? { value: data.value } : null;
        }
      }
      if (window.storage?.get) {
        return await window.storage.get(key, shared);
      }
      const value = localStorage.getItem(key);
      return value === null ? null : { value };
    } catch (e) {
      console.log('Storage get failed:', e.message);
      return null;
    }
  },
  set: async function(key, value, shared = false) {
    try {
      if (shared) {
        if (!isValidSharedKey(key)) return null;
        const socket = await getSocketClient();
        if (socket && (socket.connected || await waitForSocketConnection())) {
          await socketEmitAck('shared:set', { key, value });
          return { key, value };
        }
        const client = await getSupabaseClient();
        if (client) {
          const { error } = await client
            .from('shared_state')
            .upsert({ key, value, updated_at: new Date().toISOString() }, { onConflict: 'key' });
          if (error) throw error;
          return { key, value };
        }
      }
      if (window.storage?.set) {
        return await window.storage.set(key, value, shared);
      }
      localStorage.setItem(key, value);
      return { key, value };
    } catch (e) {
      console.error('Storage set failed:', e.message);
      return null;
    }
  }
};

// Player Manager
const PlayerManager = {
  async createProfile(name, avatar) {
    const profile = {
      id: 'player-' + Date.now(),
      name: normalizeName(name),
      avatar: avatar,
      level: 1,
      xp: 0,
      stats: {
        gamesPlayed: 0,
        activitiesCompleted: 0,
        participationInputs: 0
      },
      badges: [],
      created: Date.now()
    };
    
    await Storage.set('player-profile', JSON.stringify(profile), false);
    return profile;
  },
  
  async loadProfile() {
    const result = await Storage.get('player-profile', false);
    return result ? safeParseJson(result.value) : null;
  },
  
  async updateProfile(profile) {
    await Storage.set('player-profile', JSON.stringify(profile), false);
  },
  
  getXpForNextLevel(level) {
    // Near-exponential curve: level 1=>1000, then grows by ~22% each level.
    const base = 1000;
    const growth = 1.22;
    const safeLevel = Math.max(1, Number(level) || 1);
    return Math.round(base * Math.pow(growth, safeLevel - 1));
  },

  async awardXP(amount, reason) {
    const profile = await this.loadProfile();
    if (!profile) return;
    
    profile.xp += amount;
    
    // Level up logic (supports multiple level jumps in one award)
    let leveledUp = false;
    while (profile.xp >= this.getXpForNextLevel(profile.level)) {
      const xpForNextLevel = this.getXpForNextLevel(profile.level);
      profile.level++;
      profile.xp = profile.xp - xpForNextLevel;
      leveledUp = true;
    }
    if (leveledUp) {
      console.log('ğŸ‰ Level up!', profile.level);
      showLevelUp(profile.level);
    }
    
    await this.updateProfile(profile);
    return profile;
  },
  
  async incrementGames() {
    const profile = await this.loadProfile();
    if (!profile) return;
    
    profile.stats.gamesPlayed = (profile.stats.gamesPlayed || 0) + 1;
    await this.updateProfile(profile);
  }
};

async function awardParticipationInput(room, actionKey, points = 5) {
  if (!room || !APP.player?.name || !actionKey) return;
  room.activityState = room.activityState || {};
  const awards = room.activityState.participationAwards || {};
  if (awards[actionKey]) return;
  awards[actionKey] = Date.now();
  room.activityState.participationAwards = awards;

  const updatedProfile = await PlayerManager.awardXP(points, `participation:${actionKey}`);
  if (!updatedProfile) return;
  updatedProfile.stats = updatedProfile.stats || {};
  updatedProfile.stats.participationInputs = (updatedProfile.stats.participationInputs || 0) + 1;
  await PlayerManager.updateProfile(updatedProfile);
  APP.player = updatedProfile;
}

// Room Manager
const RoomManager = {
  generateCode() {
    return randomAlphaNum(6);
  },
  
  async createRoom(hostName, hostAvatar) {
    const code = this.generateCode();
    const room = {
      code: code,
      host: hostName,
      participants: [{
        name: hostName,
        avatar: hostAvatar,
        isHost: true,
        ready: true
      }],
      currentActivity: null,
      activityState: {},
      activityQueue: [],
      queueIndex: 0,
      queueActive: false,
      hostSettings: getDefaultRoomHostSettings(),
      created: Date.now(),
      lastUpdate: Date.now()
    };
    
    await Storage.set(`room:${code}`, JSON.stringify(room), true);
    return room;
  },
  
  async joinRoom(code, playerName, playerAvatar) {
    const result = await Storage.get(`room:${code}`, true);
    if (!result) return null;
    
    const room = safeParseJson(result.value);
    if (!room) return null;
    
    if (!room.participants.find(p => p.name === playerName)) {
      room.participants.push({
        name: playerName,
        avatar: playerAvatar,
        isHost: false,
        ready: true
      });
      room.lastUpdate = Date.now();
      await Storage.set(`room:${code}`, JSON.stringify(room), true);
    }
    
    return room;
  },
  
  async loadRoom(code) {
    const result = await Storage.get(`room:${code}`, true);
    return result ? safeParseJson(result.value) : null;
  },
  
  async updateRoom(code, room) {
    room.lastUpdate = Date.now();
    await Storage.set(`room:${code}`, JSON.stringify(room), true);
  }
};

// App State
const APP = {
  screen: 'welcome',
  player: null,
  room: null,
  roomCode: null,
  pendingJoinCode: '',
  presentationMode: false,
  error: null,
  currentActivity: null,
  editingProfile: false,
  showHostSettings: false,
  hostSettingsTab: 'game',
  aiGenerating: false,
  aiStatus: null,
  branding: {
    appName: 'Team Builder Pro',
    tagline: 'Team building, games, and challenges - all in one place',
    accent: '#00d2d3'
  },
  preferences: {
    enableFeedbackHub: true
  },
  feedback: [],
  feedbackLoading: false,
  admin: {
    authenticated: false,
    token: localStorage.getItem('admin-token') || '',
    feedback: [],
    loading: false
  }
};
const APP_VERSION = 'v1.0.0';

const TRIVIA_BANK = [
  { q: "What is the capital of France?", opts: ["London", "Paris", "Berlin", "Rome"], ans: 1 },
  { q: "How many continents are there?", opts: ["5", "6", "7", "8"], ans: 2 },
  { q: "What is the largest ocean?", opts: ["Atlantic", "Indian", "Arctic", "Pacific"], ans: 3 },
  { q: "Which planet is closest to the Sun?", opts: ["Venus", "Mercury", "Mars", "Earth"], ans: 1 },
  { q: "What is the chemical symbol for gold?", opts: ["Go", "Gd", "Au", "Ag"], ans: 2 },
  { q: "How many hearts does an octopus have?", opts: ["One", "Two", "Three", "Four"], ans: 2 },
  { q: "What year did World War II end?", opts: ["1943", "1944", "1945", "1946"], ans: 2 },
  { q: "What is the smallest country?", opts: ["Monaco", "Vatican City", "San Marino", "Malta"], ans: 1 },
  { q: "Which element has atomic number 1?", opts: ["Helium", "Hydrogen", "Oxygen", "Carbon"], ans: 1 },
  { q: "How many strings does a guitar have?", opts: ["4", "5", "6", "7"], ans: 2 }
];

let HOST_LOCAL_CONFIG = loadHostLocalConfig();

const ICEBREAKER_QUESTIONS = [
  "If you could have dinner with anyone, living or dead, who would it be?",
  "What's a skill you'd love to master?",
  "What's your favorite way to spend a weekend?",
  "If you could live anywhere for a year, where would you go?",
  "What's the best advice you've ever received?",
  "What's your go-to karaoke song?",
  "What's something you're proud of that might surprise people?",
  "If you could instantly become an expert in something, what would it be?",
  "What's a book, movie, or show that changed your perspective?",
  "What's your favorite childhood memory?",
  "What's one small thing that always improves your day?",
  "What's your most-used productivity hack?",
  "What hobby would you pick up if time wasn't a constraint?",
  "What's a place you'd love to visit next and why?",
  "What's a recent win you had, big or small?",
  "What's a food you could eat every week and not get bored?",
  "What's one thing people often misunderstand about your role?",
  "If your life had a theme song this week, what would it be?",
  "What's a challenge you've overcome that shaped you?",
  "What's your favorite way to recharge after a long day?",
  "What's one app or tool you couldn't live without?",
  "What was your first job, and what did it teach you?",
  "If you could swap roles for a day with anyone, who and why?",
  "What's your favorite tradition (family, cultural, or personal)?",
  "What's a goal you're currently working toward?",
  "What's your ideal remote-work setup?",
  "What's one skill from outside work that helps you at work?",
  "What's a random fun fact about you?",
  "If you could mentor your younger self, what would you say?"
];

const PULSE_QUESTIONS = [
  { q: "How energized are you feeling today?", opts: ["ğŸ”¥ Super charged", "ğŸ˜Š Pretty good", "ğŸ˜ Neutral", "ğŸ˜´ Need coffee"] },
  { q: "What's our team's biggest strength?", opts: ["Communication", "Innovation", "Collaboration", "Problem-solving"] },
  { q: "Ideal team lunch?", opts: ["ğŸ• Pizza", "ğŸŒ® Tacos", "ğŸ Italian", "ğŸ± Sushi"] },
  { q: "How clear are current priorities?", opts: ["Crystal clear", "Mostly clear", "Somewhat unclear", "Need alignment"] },
  { q: "How manageable is workload this week?", opts: ["Very manageable", "Balanced", "A bit heavy", "Overloaded"] },
  { q: "How confident are we in our sprint goals?", opts: ["Very confident", "Mostly confident", "Mixed", "Low confidence"] },
  { q: "Biggest blocker right now?", opts: ["Dependencies", "Scope", "Time", "Communication"] },
  { q: "How effective are our meetings lately?", opts: ["Very effective", "Mostly useful", "Could improve", "Too many meetings"] },
  { q: "Team collaboration this week feels...", opts: ["Excellent", "Good", "Inconsistent", "Needs support"] },
  { q: "How safe do you feel sharing concerns?", opts: ["Very safe", "Mostly safe", "Sometimes", "Not enough"] },
  { q: "Current team morale?", opts: ["High", "Steady", "Mixed", "Low"] },
  { q: "How well are we handling context switching?", opts: ["Great", "Okay", "Challenging", "Very hard"] },
  { q: "How likely are we to hit our deadline?", opts: ["Very likely", "Likely", "Unsure", "At risk"] },
  { q: "What should we prioritize improving first?", opts: ["Planning", "Execution", "Communication", "Quality"] },
  { q: "How supported do you feel by teammates?", opts: ["Strongly supported", "Supported", "Somewhat", "Need more support"] },
  { q: "How healthy is our feedback culture?", opts: ["Excellent", "Good", "Needs work", "Weak"] },
  { q: "How often are we celebrating wins?", opts: ["Consistently", "Sometimes", "Rarely", "Almost never"] }
];

const TEAM_VALUES = [
  { name: 'Innovation', icon: 'ğŸ’¡' },
  { name: 'Collaboration', icon: 'ğŸ¤' },
  { name: 'Integrity', icon: 'âœ¨' },
  { name: 'Excellence', icon: 'ğŸ¯' },
  { name: 'Growth', icon: 'ğŸŒ±' },
  { name: 'Balance', icon: 'âš–ï¸' },
  { name: 'Creativity', icon: 'ğŸ¨' },
  { name: 'Trust', icon: 'ğŸ›¡ï¸' },
  { name: 'Planning', icon: 'ğŸ“‹' }
];

const WORDLE_WORDS = [
  'AGILE', 'BOOST', 'CLOUD', 'DEBUG', 'EMAIL', 'FOCUS', 'GRAPH', 'HABIT',
  'INBOX', 'LEARN', 'MERIT', 'PIVOT', 'QUEST', 'REACH', 'SCALE', 'TRUST',
  'UNITE', 'VALUE', 'WORTH', 'YIELD'
];

const WORD_CHAIN_PUZZLES = [
  {
    title: 'Chain A',
    words: ['RAIN', 'BOW', 'TIE', 'BREAK', 'DOWN', 'LOAD', 'BEARING', 'WALL']
  },
  {
    title: 'Chain B',
    words: ['STAR', 'FISH', 'BOWL', 'GAME', 'PLAN', 'B', 'MOVIE', 'NIGHT']
  },
  {
    title: 'Chain C',
    words: ['HAND', 'SHAKE', 'DOWN', 'TIME', 'LINE', 'UP', 'GRADE', 'SCHOOL']
  },
  {
    title: 'Chain D',
    words: ['BOOK', 'SHELF', 'LIFE', 'CYCLE', 'TRACK', 'SUIT', 'CASE', 'STUDY']
  },
  {
    title: 'Chain E',
    words: ['SUN', 'FLOWER', 'POT', 'LUCK', 'CHARM', 'BRACELET', 'CASE', 'FILE']
  },
  {
    title: 'Chain F',
    words: ['NEWS', 'PAPER', 'CLIP', 'BOARD', 'GAME', 'PLAN', 'B', 'MOVIE']
  },
  {
    title: 'Chain G',
    words: ['TOOTH', 'BRUSH', 'STROKE', 'OF', 'COURSE', 'WORK', 'SPACE', 'BAR']
  },
  {
    title: 'Chain H',
    words: ['EAR', 'RING', 'TONE', 'DEAF', 'LEAF', 'BLOWER', 'MOTOR', 'BIKE']
  },
  {
    title: 'Chain I',
    words: ['WATER', 'FALL', 'BACK', 'PACK', 'RAT', 'RACE', 'TRACK', 'SUIT']
  },
  {
    title: 'Chain J',
    words: ['BLACK', 'BOARD', 'ROOM', 'SERVICE', 'DOG', 'HOUSE', 'PLANT', 'FOOD']
  },
  {
    title: 'Chain K',
    words: ['MAIL', 'BOX', 'OFFICE', 'HOUR', 'GLASS', 'DOOR', 'BELL', 'HOP']
  }
];

const EMOJI_CHARADES_BANK = [
  { emojis: 'ğŸŒ®ğŸ””', answer: 'Taco Bell' },
  { emojis: 'ğŸ§Šâ˜•', answer: 'Iced coffee' },
  { emojis: 'ğŸ•·ï¸ğŸ‘¨', answer: 'Spider-Man' },
  { emojis: 'ğŸ¦ğŸ‘‘', answer: 'Lion King' },
  { emojis: 'ğŸš€ğŸ‘¨â€ğŸš€', answer: 'Astronaut' },
  { emojis: 'ğŸ“±ğŸ”‹', answer: 'Phone battery' },
  { emojis: 'ğŸ¸â­', answer: 'Rock star' },
  { emojis: 'ğŸ•ğŸ‰', answer: 'Pizza party' },
  { emojis: 'ğŸŒ§ï¸ğŸŒˆ', answer: 'Rainbow' },
  { emojis: 'ğŸ§ âš¡', answer: 'Brainstorm' },
  { emojis: 'ğŸŸğŸŸ', answer: 'Fish and chips' },
  { emojis: 'ğŸ¿ğŸ¬', answer: 'Movie night' }
];

const ACTIVITY_QUEUE_ITEMS = [
  { id: 'lightning-trivia', icon: 'âš¡', label: 'Lightning Trivia' },
  { id: 'emoji-charades', icon: 'ğŸ­', label: 'Emoji Charades' },
  { id: 'icebreaker', icon: 'ğŸ²', label: 'Icebreaker Roulette' },
  { id: 'pulse-check', icon: 'ğŸ“Š', label: 'Team Pulse Check' },
  { id: 'values-vote', icon: 'â­', label: 'Values Vote' },
  { id: 'wordle', icon: 'ğŸ¯', label: 'Team Wordle' },
  { id: 'word-chain', icon: 'ğŸ”—', label: 'Word Chain' },
  { id: 'brainstorm-canvas', icon: 'ğŸ§©', label: 'Brainstorm Canvas' },
  { id: 'regular-trivia', icon: 'ğŸ§ ', label: 'Trivia Battle' }
];
const ACTIVITY_QUEUE_ITEM_MAP = Object.fromEntries(ACTIVITY_QUEUE_ITEMS.map(item => [item.id, item]));
const GAME_ACTIVITY_IDS = new Set([
  'lightning-trivia',
  'regular-trivia',
  'wordle',
  'word-chain',
  'emoji-charades'
]);
const AI_GENERATION_TARGETS = [
  { id: 'lightning-trivia', label: 'Lightning Trivia' },
  { id: 'emoji-charades', label: 'Emoji Charades' },
  { id: 'regular-trivia', label: 'Trivia Battle' },
  { id: 'icebreaker', label: 'Icebreaker Roulette' },
  { id: 'pulse-check', label: 'Team Pulse Check' },
  { id: 'values-vote', label: 'Values Vote' },
  { id: 'wordle', label: 'Team Wordle' },
  { id: 'word-chain', label: 'Word Chain' },
  { id: 'brainstorm-canvas', label: 'Brainstorm Canvas' }
];
const AI_GENERATION_TARGET_LABELS = Object.fromEntries(AI_GENERATION_TARGETS.map(item => [item.id, item.label]));

const BRAINSTORM_LANES = [
  { id: 'start', label: 'Start', icon: 'ğŸš€' },
  { id: 'stop', label: 'Stop', icon: 'ğŸ›‘' },
  { id: 'improve', label: 'Improve', icon: 'ğŸ› ï¸' },
  { id: 'create', label: 'Create', icon: 'âœ¨' }
];
const BRAINSTORM_LANE_INDEX = Object.fromEntries(BRAINSTORM_LANES.map((lane, idx) => [lane.id, idx]));
const BRAINSTORM_NOTE_COLORS = ['#fef3a7', '#bfdbfe', '#fecdd3', '#bbf7d0', '#ddd6fe', '#fdba74'];

let syncInterval = null;
let roomChannel = null;
let roomRealtimeEnabled = false;
let lightningAutoRevealPending = false;
let wordChainDraft = {};
let hostWordleDraft = '';
const TEAM_CHAIN_KEY = '__team__';
let wordChainLastAutoFocusKey = '';
let wordChainFocusCueTimer = null;
let brainstormDraggedNoteId = null;
const ROOM_SYNC_MS = 300;

// Activity Start Functions (must be before render functions)
function createInitialActivityState(activityId) {
  if (activityId === 'lightning-trivia') {
    return {
      currentQ: 0,
      revealed: false,
      answers: {},
      scores: {},
      lastPoints: {},
      answerTimes: {},
      reactions: [],
      questionOrder: buildShuffledQuestionOrder(TRIVIA_BANK.length),
      startTime: Date.now()
    };
  }
  if (activityId === 'icebreaker') {
    const randomQ = ICEBREAKER_QUESTIONS[Math.floor(Math.random() * ICEBREAKER_QUESTIONS.length)];
    return {
      currentQuestion: randomQ,
      answers: {}
    };
  }
  if (activityId === 'emoji-charades') {
    return {
      round: 0,
      revealed: false,
      guesses: {},
      scores: {},
      roundPoints: {},
      questionOrder: buildShuffledQuestionOrder(EMOJI_CHARADES_BANK.length),
      roundsTotal: Math.min(8, EMOJI_CHARADES_BANK.length),
      startedAt: Date.now()
    };
  }
  if (activityId === 'pulse-check') {
    const questionOrder = buildShuffledQuestionOrder(PULSE_QUESTIONS.length);
    const selectedPollIndexes = questionOrder.slice(0, Math.min(5, PULSE_QUESTIONS.length));
    return {
      currentPoll: 0,
      selectedPollIndexes,
      votes: {},
      voteHistory: {},
      showResults: false
    };
  }
  if (activityId === 'values-vote') {
    return { votes: {} };
  }
  if (activityId === 'wordle') {
    const word = WORDLE_WORDS[Math.floor(Math.random() * WORDLE_WORDS.length)];
    return {
      targetWord: word,
      guesses: [],
      currentRow: 0,
      gameOver: false,
      answers: {},
      wordleVotes: {}
    };
  }
  if (activityId === 'word-chain') {
    const puzzleIndex = Math.floor(Math.random() * WORD_CHAIN_PUZZLES.length);
    const puzzleWords = WORD_CHAIN_PUZZLES[puzzleIndex]?.words || [];
    return {
      puzzleIndex,
      progressIndex: {},
      revealedLetters: {},
      lastLetterGraceUsed: {},
      solvedWords: {},
      wordScores: {},
      wordAttempts: {},
      totalAttempts: {},
      completedAt: {},
      scores: {},
      feedback: {},
      chainSuggestions: {},
      chainVotes: {},
      startedAt: Date.now(),
      wordCount: Math.min(8, puzzleWords.length)
    };
  }
  if (activityId === 'brainstorm-canvas') {
    return {
      boardType: 'start-stop-improve-create',
      notes: [],
      sessionStatus: 'open',
      createdAt: Date.now()
    };
  }
  if (activityId === 'regular-trivia') {
    return {
      currentQ: 0,
      revealed: false,
      answers: {},
      scores: {},
      lastPoints: {},
      answerTimes: {},
      questionOrder: buildShuffledQuestionOrder(TRIVIA_BANK.length),
      startTime: Date.now()
    };
  }
  return null;
}

function getInitialActivityState(room, activityId) {
  let initialState = createInitialActivityState(activityId);
  if (activityId === 'brainstorm-canvas' && room?.brainstormData && typeof room.brainstormData === 'object') {
    const resumed = safeParseJson(JSON.stringify(room.brainstormData));
    if (resumed && typeof resumed === 'object') {
      initialState = resumed;
    }
  }
  return initialState;
}

async function startActivityById(activityId) {
  if (!APP.roomCode || !APP.room) return false;
  const room = { ...APP.room };
  const initialState = getInitialActivityState(room, activityId);
  if (!initialState) {
    showError('Unsupported activity.');
    return false;
  }
  lightningAutoRevealPending = false;
  room.currentActivity = activityId;
  room.activityState = initialState;
  await RoomManager.updateRoom(APP.roomCode, room);
  APP.room = room;
  if (activityId === 'word-chain') {
    wordChainDraft = {};
    resetWordChainFocusState();
  }
  if (activityId === 'wordle') {
    hostWordleDraft = '';
  }
  render();
  return true;
}

async function runNextQueuedActivity(roomOverride = null) {
  const room = roomOverride ? { ...roomOverride } : await RoomManager.loadRoom(APP.roomCode);
  if (!room) return false;
  const queue = Array.isArray(room.activityQueue) ? room.activityQueue : [];
  let queueIndex = Number.isInteger(room.queueIndex) ? room.queueIndex : 0;
  if (!room.queueActive || queue.length === 0) return false;

  while (queueIndex < queue.length && !ACTIVITY_QUEUE_ITEM_MAP[queue[queueIndex]]) {
    queueIndex++;
  }

  if (queueIndex >= queue.length) {
    room.queueActive = false;
    room.queueIndex = 0;
    room.currentActivity = null;
    room.activityState = {};
    await RoomManager.updateRoom(APP.roomCode, room);
    APP.room = room;
    render();
    return false;
  }

  const activityId = queue[queueIndex];
  room.queueIndex = queueIndex + 1;
  room.currentActivity = activityId;
  room.activityState = getInitialActivityState(room, activityId) || {};
  await RoomManager.updateRoom(APP.roomCode, room);
  APP.room = room;
  APP.screen = 'lobby';
  if (activityId === 'word-chain') {
    wordChainDraft = {};
    resetWordChainFocusState();
  }
  if (activityId === 'wordle') {
    hostWordleDraft = '';
  }
  render();
  return true;
}

async function startLightningTrivia() { await startActivityById('lightning-trivia'); }
async function startEmojiCharades() { await startActivityById('emoji-charades'); }
async function startIcebreaker() { await startActivityById('icebreaker'); }
async function startPulseCheck() { await startActivityById('pulse-check'); }
async function startValuesVote() { await startActivityById('values-vote'); }
async function startWordle() { await startActivityById('wordle'); }
async function startWordChain() { await startActivityById('word-chain'); }
async function startBrainstormCanvas() { await startActivityById('brainstorm-canvas'); }
async function startRegularTrivia() { await startActivityById('regular-trivia'); }

// Lightning Trivia Functions
async function submitAnswer(optionIndex) {
  const startTime = APP.room.activityState.startTime || Date.now();
  const timeElapsed = (Date.now() - startTime) / 1000;
  
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room.activityState.answers) room.activityState.answers = {};
  if (!room.activityState.answerTimes) room.activityState.answerTimes = {};
  
  room.activityState.answers[APP.player.name] = optionIndex;
  room.activityState.answerTimes[APP.player.name] = Math.min(timeElapsed, 20);
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function sendLightningReaction(emoji) {
  if (!emoji || APP.room?.currentActivity !== 'lightning-trivia') return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'lightning-trivia') return;

  if (!room.activityState.reactions) room.activityState.reactions = [];
  room.activityState.reactions.push({
    emoji,
    player: APP.player.name,
    ts: Date.now()
  });
  room.activityState.reactions = room.activityState.reactions.slice(-25);

  await RoomManager.updateRoom(APP.roomCode, room);
}

async function revealAnswer() {
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.activityState?.revealed) return;
  room.activityState.revealed = true;
  const hostSettings = getRoomHostSettings(room);
  
  const currentQ = room.activityState.currentQ;
  const questionIndex = room.activityState.questionOrder?.[currentQ] ?? currentQ;
  const question = TRIVIA_BANK[questionIndex];
  const answers = room.activityState.answers || {};
  const answerTimes = room.activityState.answerTimes || {};
  
  if (!room.activityState.scores) room.activityState.scores = {};
  if (!room.activityState.lastPoints) room.activityState.lastPoints = {};
  
  Object.entries(answers).forEach(([playerName, ans]) => {
    room.activityState.lastPoints[playerName] = 0;
    
    if (ans === question.ans) {
      let points = 1000;
      if (hostSettings.dynamicScoring) {
        const timeUsed = answerTimes[playerName] || 20;
        const timeRemaining = Math.max(0, 20 - timeUsed);
        const timeRemainingRatio = timeRemaining / 20;
        points = Math.round(1000 + (1000 * timeRemainingRatio)); // 1000..2000
      }
      
      room.activityState.scores[playerName] = (room.activityState.scores[playerName] || 0) + points;
      room.activityState.lastPoints[playerName] = points;
    }
  });
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function nextQuestion() {
  lightningAutoRevealPending = false;
  const room = await RoomManager.loadRoom(APP.roomCode);
  room.activityState.currentQ++;
  room.activityState.revealed = false;
  room.activityState.answers = {};
  room.activityState.answerTimes = {};
  room.activityState.reactions = [];
  room.activityState.startTime = Date.now();
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function endActivity() {
  const room = await RoomManager.loadRoom(APP.roomCode);
  
  // Award XP based on activity type
  const activity = room.currentActivity;
  let xpEarned = 0;
  
  if (activity === 'lightning-trivia' || activity === 'regular-trivia') {
    const playerScore = room.activityState.scores?.[APP.player.name] || 0;
    xpEarned = Math.round(playerScore / 10);
  } else if (activity === 'icebreaker') {
    xpEarned = 50; // Participation XP
  } else if (activity === 'emoji-charades') {
    const playerScore = room.activityState.scores?.[APP.player.name] || 0;
    xpEarned = Math.max(40, Math.round(playerScore / 5));
  } else if (activity === 'pulse-check') {
    xpEarned = 30;
  } else if (activity === 'values-vote') {
    xpEarned = 40;
  } else if (activity === 'wordle') {
    const won = room.activityState.gameOver && room.activityState.guesses?.includes(room.activityState.targetWord);
    xpEarned = won ? 100 : 50;
  } else if (activity === 'word-chain') {
    const score = room.activityState.scores?.[APP.player.name] || 0;
    xpEarned = Math.max(40, Math.round(score / 25));
  } else if (activity === 'brainstorm-canvas') {
    const notes = Array.isArray(room.activityState?.notes) ? room.activityState.notes : [];
    const userNotes = notes.filter(note => note.author === APP.player.name).length;
    const userVotes = notes.filter(note => Array.isArray(note.voters) && note.voters.includes(APP.player.name)).length;
    xpEarned = Math.max(30, (userNotes * 15) + (userVotes * 5));
  }
  
  if (xpEarned > 0) {
    const updatedProfile = await PlayerManager.awardXP(xpEarned, activity);
    if (updatedProfile) {
      APP.player = updatedProfile;
    }
  }
  
  // Update activity completion stat
  APP.player.stats = APP.player.stats || {};
  if (GAME_ACTIVITY_IDS.has(activity)) {
    APP.player.stats.gamesPlayed = (APP.player.stats.gamesPlayed || 0) + 1;
  }
  APP.player.stats.activitiesCompleted = (APP.player.stats.activitiesCompleted || 0) + 1;
  await PlayerManager.updateProfile(APP.player);

  if (activity === 'brainstorm-canvas') {
    room.brainstormData = safeParseJson(JSON.stringify(room.activityState || {})) || room.activityState || {};
    room.brainstormLastUpdatedAt = Date.now();
  }
  
  room.currentActivity = null;
  room.activityState = {};
  
  await RoomManager.updateRoom(APP.roomCode, room);
  resetWordChainFocusState();

  if (room.queueActive && room.host === APP.player?.name) {
    await runNextQueuedActivity(room);
  }
}

async function playAgain() {
  if (APP.room?.currentActivity === 'regular-trivia') {
    await startRegularTrivia();
    return;
  }
  await startLightningTrivia();
}

// Regular Trivia Functions
async function submitRegularTriviaAnswer(optionIndex) {
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room.activityState.answers) room.activityState.answers = {};
  if (!room.activityState.answerTimes) room.activityState.answerTimes = {};
  
  const startTime = room.activityState.startTime || Date.now();
  const timeElapsed = (Date.now() - startTime) / 1000;
  
  room.activityState.answers[APP.player.name] = optionIndex;
  room.activityState.answerTimes[APP.player.name] = Math.min(timeElapsed, 20);
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function revealRegularAnswer() {
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.activityState.revealed) return;
  room.activityState.revealed = true;
  const hostSettings = getRoomHostSettings(room);
  
  const currentQ = room.activityState.currentQ || 0;
  const questionIndex = room.activityState.questionOrder?.[currentQ] ?? currentQ;
  const question = TRIVIA_BANK[questionIndex];
  const answers = room.activityState.answers || {};
  const answerTimes = room.activityState.answerTimes || {};
  if (!room.activityState.scores) room.activityState.scores = {};
  if (!room.activityState.lastPoints) room.activityState.lastPoints = {};
  
  // Award time-based points for correct answers (continuous scoring).
  Object.entries(answers).forEach(([playerName, answer]) => {
    let points = 0;
    if (answer === question?.ans) {
      if (hostSettings.dynamicScoring) {
        const timeUsed = Math.min(answerTimes[playerName] ?? 20, 20);
        const timeRemainingRatio = Math.max(0, (20 - timeUsed) / 20);
        points = Math.round(500 + (500 * timeRemainingRatio)); // 500..1000
      } else {
        points = 500;
      }
    }
    room.activityState.lastPoints[playerName] = points;
    room.activityState.scores[playerName] = (room.activityState.scores[playerName] || 0) + points;
  });
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function nextRegularTrivia() {
  const room = await RoomManager.loadRoom(APP.roomCode);
  room.activityState.currentQ++;
  room.activityState.revealed = false;
  room.activityState.answers = {};
  room.activityState.answerTimes = {};
  room.activityState.lastPoints = {};
  room.activityState.startTime = Date.now();
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

// Emoji Charades Functions
async function submitEmojiCharadesGuess() {
  if (!APP.roomCode || APP.room?.currentActivity !== 'emoji-charades') return;
  const guess = String(document.getElementById('emojiCharadesGuessInput')?.value || '').replace(/\s+/g, ' ').trim().slice(0, 60);
  if (!guess) {
    showError('Enter a guess first.');
    return;
  }

  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'emoji-charades') return;
  if (room.activityState?.revealed) return;

  if (!room.activityState.guesses || typeof room.activityState.guesses !== 'object') {
    room.activityState.guesses = {};
  }
  room.activityState.guesses[APP.player.name] = guess;

  await RoomManager.updateRoom(APP.roomCode, room);
  APP.room = room;
  render();
}

async function revealEmojiCharades() {
  if (!APP.roomCode || !APP.room || APP.room.host !== APP.player?.name || APP.room.currentActivity !== 'emoji-charades') return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'emoji-charades') return;
  const state = room.activityState || {};
  if (state.revealed) return;

  const round = Number.isInteger(state.round) ? state.round : 0;
  const roundsTotal = Math.max(1, Math.min(8, Number.parseInt(state.roundsTotal || '8', 10) || 8));
  if (round >= roundsTotal) return;
  const questionIndex = state.questionOrder?.[round] ?? round;
  const prompt = EMOJI_CHARADES_BANK[questionIndex];
  if (!prompt) return;

  const answerKey = normalizeCharadesAnswer(prompt.answer);
  const guesses = state.guesses && typeof state.guesses === 'object' ? state.guesses : {};
  const scores = state.scores && typeof state.scores === 'object' ? state.scores : {};
  const roundPoints = {};

  APP.room.participants.forEach(player => {
    const guessKey = normalizeCharadesAnswer(guesses[player.name] || '');
    const points = guessKey && guessKey === answerKey ? 100 : 0;
    roundPoints[player.name] = points;
    if (points > 0) {
      scores[player.name] = (scores[player.name] || 0) + points;
    }
  });

  room.activityState = {
    ...state,
    revealed: true,
    scores,
    roundPoints
  };
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function nextEmojiCharadesRound() {
  if (!APP.roomCode || !APP.room || APP.room.host !== APP.player?.name || APP.room.currentActivity !== 'emoji-charades') return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'emoji-charades') return;
  const state = room.activityState || {};
  const nextRound = (Number.isInteger(state.round) ? state.round : 0) + 1;

  room.activityState = {
    ...state,
    round: nextRound,
    revealed: false,
    guesses: {},
    roundPoints: {}
  };
  await RoomManager.updateRoom(APP.roomCode, room);
}

// Icebreaker Functions
function autoFocusWordChainActiveCell() {
  if (APP.room?.currentActivity !== 'word-chain') {
    wordChainLastAutoFocusKey = '';
    return;
  }
  if (APP.room.host !== APP.player?.name) return;
  const state = APP.room.activityState || {};
  const puzzle = WORD_CHAIN_PUZZLES[state.puzzleIndex];
  if (!puzzle) return;
  const chain = (puzzle.words || []).slice(0, Math.min(8, state.wordCount || 8));
  const lastIndex = chain.length - 1;
  if (lastIndex < 2) return;

  const playerName = TEAM_CHAIN_KEY;
  const progress = state.progressIndex?.[playerName] || 1;
  if (progress >= lastIndex) return;

  const rowLength = normalizeChainWord(chain[progress] || '').slice(0, 9).length;
  const revealCount = Math.max(1, Math.min(rowLength, state.revealedLetters?.[playerName]?.[progress] || 1));
  const focusKey = `${APP.roomCode || ''}:${playerName}:${progress}:${revealCount}`;
  if (focusKey === wordChainLastAutoFocusKey) return;

  const target = document.querySelector(`.word-chain-letter-input[data-row="${progress}"][data-first-editable="true"]`);
  if (!(target instanceof HTMLInputElement)) return;
  target.focus();
  target.select();
  if (wordChainFocusCueTimer) clearTimeout(wordChainFocusCueTimer);
  target.classList.remove('autofocus-cue');
  void target.offsetWidth;
  target.classList.add('autofocus-cue');
  wordChainFocusCueTimer = setTimeout(() => {
    target.classList.remove('autofocus-cue');
    wordChainFocusCueTimer = null;
  }, 420);
  wordChainLastAutoFocusKey = focusKey;
}

function render() {
  const app = document.getElementById('app');
  let html = '';

  if (APP.editingProfile) html = renderEditProfile();
  else if (APP.screen === 'welcome') html = renderWelcome();
  else if (APP.screen === 'dashboard') html = renderDashboard();
  else if (APP.screen === 'about') html = renderAboutApp();
  else if (APP.screen === 'create-room') html = renderCreateRoom();
  else if (APP.screen === 'join-room') html = renderJoinRoom();
  else if (APP.screen === 'lobby') html = renderLobby();
  else if (APP.screen === 'activity-queue') html = renderActivityQueue();
  else if (APP.screen === 'feedback') html = renderFeedbackHub();
  else if (APP.screen === 'admin') html = renderAdminConsole();
  else if (APP.screen === 'schedule-meeting') html = renderScheduleMeeting();
  else if (APP.screen === 'load-session') html = renderLoadSession();

  if (APP.showHostSettings && APP.room && APP.room.host === APP.player?.name) {
    html += renderHostSettingsModal();
  }
  
  if (APP.error) {
    const safeError = escapeHtml(APP.error);
    html = `
      <div style="position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:9999;
        background:var(--surface-solid);border:2px solid var(--danger);border-radius:12px;
        padding:16px 24px;box-shadow:0 8px 32px rgba(0,0,0,0.5);max-width:400px;">
        <div role="alert" aria-live="assertive" aria-atomic="true" style="color:var(--danger);font-weight:600;text-align:center;">${safeError}</div>
      </div>
    ` + html;
  }
  
  app.innerHTML = html;
  autoFocusWordChainActiveCell();
}

function renderWelcome() {
  const safeAppName = escapeHtml(APP.branding.appName);
  const safeTagline = escapeHtml(APP.branding.tagline);
  return `
    <div class="header">
      <h1 class="logo">${safeAppName}</h1>
      <p class="tagline">${safeTagline}</p>
    </div>
    
    <div class="form-container">
      <h2 style="font-family:'Fraunces',serif;font-size:1.8rem;text-align:center;margin-bottom:30px;">
        Create Your Player Card
      </h2>
      
      <div class="form-group">
        <label class="form-label" for="playerName">Your Name</label>
        <input type="text" id="playerName" class="form-input" placeholder="Enter your name" autocomplete="name">
      </div>
      
      <div class="form-group">
        <label class="form-label">Choose Avatar</label>
        <div style="display:grid;grid-template-columns:repeat(6,1fr);gap:10px;">
          ${AVATAR_OPTIONS.map(av => `
            <button data-action="select-avatar" data-avatar="${av}" id="av-${av}" 
              style="font-size:2rem;padding:10px;background:var(--surface-2);border:2px solid ${av === selectedAvatar ? 'var(--accent)' : 'var(--border)'};
              border-radius:10px;cursor:pointer;transition:all 0.3s;">
              ${av}
            </button>
          `).join('')}
        </div>
      </div>
      
      <button class="btn-primary" data-action="create-player">Continue</button>
    </div>
  `;
}

function renderDashboard() {
  const safePlayerName = escapeHtml(APP.player.name);
  const safeAppName = escapeHtml(APP.branding.appName);
  const showFeedback = APP.preferences.enableFeedbackHub !== false;
  return `
    <div class="header">
      <h1 class="logo">${safeAppName}</h1>
    </div>
    
    <div class="player-card">
      <div class="avatar-circle">${APP.player.avatar}</div>
      <div class="player-info">
        <div class="player-name">${safePlayerName}</div>
        <div class="player-stats">
          <span class="stat">â­ Level ${APP.player.level}</span>
          <span class="stat">âœ¦ ${APP.player.xp} XP</span>
          <span class="stat">ğŸ® ${APP.player.stats.gamesPlayed} games</span>
        </div>
      </div>
      <div class="level-badge">Level ${APP.player.level}</div>
    </div>
    
    <div class="grid-2">
      <button type="button" class="card" data-action="go-screen" data-screen="create-room" aria-label="Host Session">
        <div class="card-icon">ğŸ‘‘</div>
        <h3 class="card-title">Host Session</h3>
        <p class="card-desc">Create a room and choose activities for your team</p>
      </button>
      
      <button type="button" class="card" data-action="go-screen" data-screen="join-room" aria-label="Join Session">
        <div class="card-icon">ğŸ®</div>
        <h3 class="card-title">Join Session</h3>
        <p class="card-desc">Enter a room code to join your team</p>
      </button>

        <button type="button" class="card" data-action="go-screen" data-screen="schedule-meeting" aria-label="Schedule Team Meeting">
          <div class="card-icon">ğŸ“…</div>
          <h3 class="card-title">Schedule Team Meeting</h3>
          <p class="card-desc">Set up a date, time, Zoom link, and meeting details</p>
        </button>

        <button type="button" class="card" data-action="go-screen" data-screen="load-session" aria-label="Load Saved Session">
          <div class="card-icon">ğŸ’¾</div>
          <h3 class="card-title">Load Saved Session</h3>
          <p class="card-desc">Select and load a previously saved session</p>
        </button>
    </div>
    
    <div style="text-align:center;margin-top:40px;">
      <button class="btn-secondary" data-action="view-stats">â„¹ï¸ About App</button>
      <button class="btn-secondary" data-action="edit-profile" style="margin-left:10px;">âœï¸ Edit Profile</button>
      ${showFeedback ? '<button class="btn-secondary" data-action="open-feedback" style="margin-left:10px;">ğŸ—£ï¸ Feedback Hub</button>' : ''}
      <button class="btn-secondary" data-action="open-admin-console" style="margin-left:10px;">ğŸ› ï¸ Admin Console</button>
    </div>
  `;
}

function renderAboutApp() {
  const safeAppName = escapeHtml(APP.branding.appName || 'Team Builder Pro');
  const safeVersion = escapeHtml(APP_VERSION);
  return `
    <div class="header">
      <h1 class="logo">About App</h1>
      <p class="tagline">${safeAppName} â€¢ Version ${safeVersion}</p>
    </div>

    <button class="btn-secondary" data-action="go-screen" data-screen="dashboard">â† Back</button>

    <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:var(--radius);padding:20px;margin-top:20px;">
      <h3 style="font-family:'Fraunces',serif;font-size:1.3rem;margin-bottom:10px;">General Purpose</h3>
      <p style="color:var(--text-mid);line-height:1.6;">
        A host-led team engagement app for running interactive activities in one shared room, with lightweight multiplayer sync and facilitator controls.
      </p>
    </div>

    <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:var(--radius);padding:20px;margin-top:16px;">
      <h3 style="font-family:'Fraunces',serif;font-size:1.3rem;margin-bottom:10px;">Highlights</h3>
      <div style="display:grid;gap:10px;color:var(--text-mid);line-height:1.5;">
        <div>â€¢ Multi-activity library: Lightning Trivia, Emoji Charades, Team Pulse, Values Vote, Wordle, Word Chain, and Brainstorm Canvas.</div>
        <div>â€¢ Host controls: activity queue, room settings, and guided session flow.</div>
        <div>â€¢ Brainstorm collaboration: sticky notes, upvotes, lane movement, and JSON/CSV export.</div>
        <div>â€¢ Pulse reporting: export team sentiment snapshots to JSON or CSV.</div>
        <div>â€¢ Session UX: editable profile, leave session control, and room-based collaboration.</div>
      </div>
    </div>
  `;
}

function renderEditProfile() {
  const selectedAv = selectedEditAvatar || APP.player.avatar;
  const safePlayerName = escapeHtml(APP.player.name);
  const safeSelectedEmoji = escapeHtml(selectedAv);
  
  return `
    <div class="header">
      <h1 class="logo">Edit Profile</h1>
    </div>
    
    <button class="btn-secondary" data-action="cancel-edit-profile">â† Back</button>
    
    <div class="form-container" style="margin-top:20px;">
      <h2 style="font-family:'Fraunces',serif;font-size:1.8rem;text-align:center;margin-bottom:30px;">
        Update Your Profile
      </h2>
      
      <div class="form-group">
        <label class="form-label" for="editName">Display Name</label>
        <input type="text" id="editName" class="form-input" value="${safePlayerName}" placeholder="Enter your name" autocomplete="name">
      </div>

      <div class="form-group">
        <label class="form-label" for="editEmoji">Emoji</label>
        <input type="text" id="editEmoji" class="form-input" value="${safeSelectedEmoji}" placeholder="ğŸ˜€" maxlength="8" autocomplete="off">
      </div>
      
      <div class="form-group">
        <label class="form-label">Choose Avatar</label>
        <div style="display:grid;grid-template-columns:repeat(6,1fr);gap:10px;">
          ${AVATAR_OPTIONS.map(av => `
            <button data-action="select-edit-avatar" data-avatar="${av}" id="edit-av-${av}"
              style="font-size:2rem;padding:10px;background:var(--surface-2);
              border:2px solid ${av === selectedAv ? 'var(--accent)' : 'var(--border)'};
              border-radius:10px;cursor:pointer;transition:all 0.3s;"
              class="${av === selectedAv ? 'selected' : ''}">
              ${av}
            </button>
          `).join('')}
        </div>
      </div>
      
      <div style="background:var(--surface-2);border:1px solid var(--border);
        border-radius:10px;padding:20px;margin-bottom:20px;">
        <h4 style="font-weight:600;margin-bottom:12px;">Your Stats</h4>
        <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:12px;font-size:0.9rem;">
          <div>Level: <strong>${APP.player.level}</strong></div>
          <div>XP: <strong>${APP.player.xp}</strong></div>
          <div>Games: <strong>${APP.player.stats.gamesPlayed}</strong></div>
          <div>Activities: <strong>${APP.player.stats.activitiesCompleted}</strong></div>
          <div>Inputs: <strong>${APP.player.stats.participationInputs || 0}</strong></div>
        </div>
      </div>
      
      <button class="btn-primary" data-action="save-profile">Save Changes</button>
      <button class="btn-secondary" data-action="cancel-edit-profile" style="width:100%;margin-top:10px;">Cancel</button>
    </div>
  `;
}

function renderCreateRoom() {
  const safePlayerName = escapeHtml(APP.player.name);
  return `
    <div class="header">
      <h1 class="logo">Host Session</h1>
    </div>
    
    <button class="btn-secondary" data-action="go-screen" data-screen="dashboard">â† Back</button>
    
    <div class="form-container" style="margin-top:20px;">
      <h2 style="text-align:center;margin-bottom:30px;font-family:'Fraunces',serif;font-size:1.5rem;">
        Creating Room...
      </h2>
      <p style="text-align:center;color:var(--text-dim);margin-bottom:30px;">
        Setting up your session for ${safePlayerName}
      </p>
      <div class="spinner" style="width:48px;height:48px;margin:0 auto;border:4px solid var(--surface-2);
        border-top:4px solid var(--accent);border-radius:50%;animation:spin 1s linear infinite;"></div>
    </div>
  `;
}

function renderJoinRoom() {
  const prefillCode = escapeHtml(normalizeRoomCode(APP.pendingJoinCode || ''));
  return `
    <div class="header">
      <h1 class="logo">Join Session</h1>
    </div>
    
    <button class="btn-secondary" data-action="go-screen" data-screen="dashboard">â† Back</button>
    
    <div class="form-container" style="margin-top:20px;">
      <div class="form-group">
        <label class="form-label" for="joinCode">Room Code</label>
        <input type="text" id="joinCode" class="form-input" 
          style="text-align:center;font-size:2rem;letter-spacing:8px;text-transform:uppercase;"
          maxlength="6" value="${prefillCode}" placeholder="ABC123" autocapitalize="characters" inputmode="text">
      </div>
      ${prefillCode ? `<div style="color:var(--text-dim);font-size:0.9rem;margin-bottom:10px;">Invite link detected. Tap <strong>Join Room</strong>.</div>` : ''}
      
      <button class="btn-primary" data-action="join-room">Join Room</button>
    </div>
  `;
}

function renderFeedbackHub() {
  const entries = APP.feedback || [];
  const loading = APP.feedbackLoading;
  const statusColor = {
    open: 'var(--warning)',
    in_review: 'var(--accent)',
    resolved: 'var(--success)'
  };

  return `
    <div class="header">
      <h1 class="logo">Feedback Hub</h1>
      <p class="tagline">Report UI issues and share ideas. You only see your own submissions.</p>
    </div>
    <button class="btn-secondary" data-action="go-screen" data-screen="dashboard">â† Back</button>

    <div class="form-container" style="margin-top:20px;">
      <h3 style="font-family:'Fraunces',serif;font-size:1.3rem;margin-bottom:14px;">Submit Feedback</h3>
      <div class="form-group">
        <label class="form-label" for="feedbackType">Type</label>
        <select id="feedbackType" class="form-input">
          <option value="ui">UI Issue</option>
          <option value="idea">Idea</option>
          <option value="bug">Bug</option>
          <option value="general">General</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label" for="feedbackTitle">Title</label>
        <input id="feedbackTitle" class="form-input" maxlength="120" placeholder="Short title">
      </div>
      <div class="form-group">
        <label class="form-label" for="feedbackDetails">Details</label>
        <textarea id="feedbackDetails" class="form-input" rows="4" maxlength="2000" placeholder="Describe the issue or idea"></textarea>
      </div>
      <button class="btn-primary" data-action="submit-feedback">Submit</button>
      <button class="btn-secondary" data-action="refresh-feedback" style="margin-top:10px;">Refresh My Feedback</button>
    </div>

    <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:var(--radius);padding:20px;margin-top:20px;">
      <h3 style="font-family:'Fraunces',serif;font-size:1.3rem;margin-bottom:14px;">My Feedback</h3>
      ${loading ? '<div style="color:var(--text-dim);">Loading...</div>' : ''}
      ${!loading && entries.length === 0 ? '<div style="color:var(--text-dim);">No feedback submitted yet.</div>' : ''}
      ${entries.map(item => `
        <div style="background:var(--surface-2);border:1px solid var(--border);border-radius:10px;padding:14px;margin-bottom:10px;">
          <div style="display:flex;justify-content:space-between;gap:12px;align-items:center;margin-bottom:8px;">
            <strong>${escapeHtml(item.title || '')}</strong>
            <span style="font-size:0.8rem;text-transform:uppercase;color:${statusColor[item.status] || 'var(--text-mid)'};">${escapeHtml((item.status || 'open').replace('_', ' '))}</span>
          </div>
          <div style="font-size:0.85rem;color:var(--text-dim);margin-bottom:8px;">
            ${escapeHtml((item.type || 'general').toUpperCase())} â€¢ ${escapeHtml(item.createdAt || '')}
          </div>
          <div style="margin-bottom:8px;color:var(--text-mid);">${escapeHtml(item.details || '')}</div>
          ${item.adminNotes ? `<div style="padding:10px;border-radius:8px;background:rgba(0,210,211,0.06);border:1px solid var(--accent);font-size:0.9rem;"><strong>Admin Notes:</strong> ${escapeHtml(item.adminNotes)}</div>` : ''}
        </div>
      `).join('')}
    </div>
  `;
}

function renderAdminConsole() {
  const admin = APP.admin || {};
  const safeToken = escapeHtml(admin.token || '');
  const safeAppName = escapeHtml(APP.branding.appName || '');
  const safeTagline = escapeHtml(APP.branding.tagline || '');
  const safeAccent = escapeHtml(APP.branding.accent || '#00d2d3');
  const feedback = admin.feedback || [];
  const statusColor = {
    open: 'var(--warning)',
    in_review: 'var(--accent)',
    resolved: 'var(--success)'
  };

  if (!admin.authenticated) {
    return `
      <div class="header">
        <h1 class="logo">Admin Console</h1>
        <p class="tagline">Sign in with the admin token from your server environment.</p>
      </div>
      <button class="btn-secondary" data-action="go-screen" data-screen="dashboard">â† Back</button>
      <div class="form-container" style="margin-top:20px;">
        <div class="form-group">
          <label class="form-label" for="adminToken">Admin Token</label>
          <input id="adminToken" class="form-input" value="${safeToken}" type="password" placeholder="x-admin-token">
        </div>
        <button class="btn-primary" data-action="admin-login">Login</button>
      </div>
    `;
  }

  return `
    <div class="header">
      <h1 class="logo">Admin Console</h1>
      <p class="tagline">Manage feedback workflow, branding, and global preferences.</p>
    </div>
    <button class="btn-secondary" data-action="go-screen" data-screen="dashboard">â† Back</button>
    <button class="btn-secondary" data-action="admin-logout" style="margin-left:10px;">Log Out</button>

    <div class="form-container" style="margin-top:20px;">
      <h3 style="font-family:'Fraunces',serif;font-size:1.3rem;margin-bottom:14px;">Branding & Preferences</h3>
      <div class="form-group">
        <label class="form-label" for="adminBrandAppName">App Name</label>
        <input id="adminBrandAppName" class="form-input" value="${safeAppName}" maxlength="64">
      </div>
      <div class="form-group">
        <label class="form-label" for="adminBrandTagline">Tagline</label>
        <input id="adminBrandTagline" class="form-input" value="${safeTagline}" maxlength="140">
      </div>
      <div class="form-group">
        <label class="form-label" for="adminBrandAccent">Accent Color (#RRGGBB)</label>
        <input id="adminBrandAccent" class="form-input" value="${safeAccent}" maxlength="7" placeholder="#00d2d3">
      </div>
      <label style="display:flex;align-items:center;gap:8px;margin-bottom:12px;">
        <input id="adminEnableFeedbackHub" type="checkbox" ${APP.preferences.enableFeedbackHub !== false ? 'checked' : ''}>
        Enable user Feedback Hub
      </label>
      <button class="btn-primary" data-action="save-admin-config">Save Branding & Preferences</button>
    </div>

    <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:var(--radius);padding:20px;margin-top:20px;">
      <h3 style="font-family:'Fraunces',serif;font-size:1.3rem;margin-bottom:12px;">All Feedback</h3>
      <button class="btn-secondary" data-action="refresh-admin-feedback" style="margin-bottom:12px;">Refresh</button>
      ${admin.loading ? '<div style="color:var(--text-dim);">Loading...</div>' : ''}
      ${!admin.loading && feedback.length === 0 ? '<div style="color:var(--text-dim);">No feedback available.</div>' : ''}
      ${feedback.map(item => `
        <div style="background:var(--surface-2);border:1px solid var(--border);border-radius:10px;padding:14px;margin-bottom:10px;">
          <div style="display:flex;justify-content:space-between;gap:12px;margin-bottom:8px;">
            <strong>${escapeHtml(item.title || '')}</strong>
            <span style="font-size:0.8rem;color:${statusColor[item.status] || 'var(--text-mid)'};text-transform:uppercase;">${escapeHtml((item.status || 'open').replace('_', ' '))}</span>
          </div>
          <div style="font-size:0.85rem;color:var(--text-dim);margin-bottom:8px;">
            ${escapeHtml(item.userName || 'Anonymous')} â€¢ ${escapeHtml(item.type || 'general')} â€¢ ${escapeHtml(item.createdAt || '')}
          </div>
          <div style="color:var(--text-mid);margin-bottom:10px;">${escapeHtml(item.details || '')}</div>
          <div style="display:grid;grid-template-columns:180px 1fr auto;gap:10px;">
            <select id="admin-status-${item.id}" class="form-input">
              <option value="open" ${(item.status || '') === 'open' ? 'selected' : ''}>Open</option>
              <option value="in_review" ${(item.status || '') === 'in_review' ? 'selected' : ''}>In Review</option>
              <option value="resolved" ${(item.status || '') === 'resolved' ? 'selected' : ''}>Resolved</option>
            </select>
            <input id="admin-notes-${item.id}" class="form-input" value="${escapeHtml(item.adminNotes || '')}" maxlength="2000" placeholder="Admin notes">
            <button class="btn-primary" data-action="save-admin-feedback-item" data-feedback-id="${item.id}">Save</button>
          </div>
        </div>
      `).join('')}
    </div>
  `;
}

function renderLobby() {
  const isHost = APP.room.host === APP.player.name;
  const showFeedback = APP.preferences.enableFeedbackHub !== false;
  const safeRoomCode = escapeHtml(APP.roomCode);
  const joinUrl = `${window.location.origin}${window.location.pathname}?join=${encodeURIComponent(APP.roomCode || '')}`;
  const qrImageUrl = `https://api.qrserver.com/v1/create-qr-code/?size=220x220&data=${encodeURIComponent(joinUrl)}`;
  const safeJoinUrl = escapeHtml(joinUrl);
  const sharedPresentation = ENABLE_PRESENTATION_SHARE ? (APP.room.sharedPresentation || null) : null;
  const safePresentationTitle = escapeHtml(sharedPresentation?.title || 'Shared Presentation');
  const safePresentationUrl = escapeHtml(sharedPresentation?.url || '');
  const safeSharedBy = escapeHtml(sharedPresentation?.sharedBy || '');
  const sharedAtLabel = sharedPresentation?.updatedAt ? new Date(sharedPresentation.updatedAt).toLocaleString() : '';
  
  if (APP.room.currentActivity) {
    return renderActivity();
  }
  
  return `
    <div style="display:flex;justify-content:flex-end;gap:10px;margin-bottom:8px;">
      <button class="btn-secondary" data-action="edit-profile">âœï¸ Edit Profile</button>
      ${showFeedback ? '<button class="btn-secondary" data-action="open-feedback">ğŸ—£ï¸ Feedback</button>' : ''}
      <button class="btn-secondary" data-action="leave-session">ğŸšª Leave Session</button>
      ${isHost ? '<button class="btn-secondary" data-action="go-screen" data-screen="activity-queue">ğŸ—‚ï¸ Activity Queue</button>' : ''}
      ${isHost ? '<button class="btn-secondary" data-action="open-host-settings">âš™ï¸ Host Settings</button>' : ''}
    </div>

    <div class="header">
      <h1 class="logo">Session Lobby</h1>
      <p class="tagline">Room: ${safeRoomCode}</p>
    </div>
    
    <div style="background:rgba(0,210,211,0.05);border:2px solid var(--accent);
      border-radius:var(--radius);padding:24px;margin-bottom:24px;">
      <div class="qr-grid" style="display:grid;grid-template-columns:${isHost ? '1.4fr 1fr' : '1fr'};gap:18px;align-items:center;">
        <div style="text-align:center;">
          <div style="font-size:0.85rem;color:var(--text-dim);margin-bottom:8px;text-transform:uppercase;letter-spacing:1px;">
            Room Code
          </div>
          <div style="font-family:'IBM Plex Mono',monospace;font-size:3rem;font-weight:700;
            letter-spacing:12px;color:var(--accent);margin:10px 0;">
            ${safeRoomCode}
          </div>
          <div style="font-size:0.85rem;color:var(--text-dim);">Share with your team</div>
          ${isHost ? `
            <div style="margin-top:10px;color:var(--text-dim);font-size:0.82rem;word-break:break-all;">
              ${safeJoinUrl}
            </div>
            <button class="btn-secondary" data-action="copy-join-link" style="margin-top:10px;">Copy Join Link</button>
          ` : ''}
        </div>
        ${isHost ? `
          <div style="text-align:center;">
            <div style="font-weight:700;margin-bottom:10px;">Scan to Join</div>
            <img src="${qrImageUrl}" alt="QR code to join session" width="220" height="220"
              style="width:220px;height:220px;max-width:100%;border-radius:12px;border:1px solid var(--border);background:#fff;padding:8px;">
          </div>
        ` : ''}
      </div>
    </div>

    ${ENABLE_PRESENTATION_SHARE ? `
    <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:var(--radius);padding:20px;margin-bottom:24px;">
      <h3 style="font-weight:700;margin-bottom:12px;">ğŸ“‘ Shared Presentation</h3>
      ${sharedPresentation ? `
        <div style="background:var(--surface-2);border:1px solid var(--border);border-radius:10px;padding:14px;margin-bottom:12px;">
          <div style="font-weight:700;margin-bottom:6px;">${safePresentationTitle}</div>
          <div style="font-size:0.85rem;color:var(--text-mid);word-break:break-all;">${safePresentationUrl}</div>
          <div style="font-size:0.78rem;color:var(--text-dim);margin-top:8px;">
            Shared by ${safeSharedBy || 'host'}${sharedAtLabel ? ` â€¢ ${escapeHtml(sharedAtLabel)}` : ''}
          </div>
        </div>
        <button class="btn-primary" data-action="open-shared-presentation">Open Presentation</button>
        ${isHost ? '<button class="btn-secondary" data-action="clear-shared-presentation" style="margin-top:10px;">Clear Shared Presentation</button>' : ''}
      ` : `
        <div style="color:var(--text-dim);margin-bottom:12px;">No presentation shared yet.</div>
      `}

      ${isHost ? `
        <div style="margin-top:12px;border-top:1px solid var(--border);padding-top:12px;">
          <div class="form-group" style="margin-bottom:10px;">
            <label class="form-label" for="presentationTitle">Title (optional)</label>
            <input id="presentationTitle" class="form-input" maxlength="120" placeholder="Q4 Planning Deck">
          </div>
          <div class="form-group" style="margin-bottom:10px;">
            <label class="form-label" for="presentationUrl">Presentation URL</label>
            <input id="presentationUrl" class="form-input" maxlength="1000" placeholder="https://...">
          </div>
          <button class="btn-secondary" data-action="save-shared-presentation">Share Presentation Link</button>
        </div>
      ` : ''}
    </div>
    ` : ''}
    
    <div style="background:var(--surface-solid);border:1px solid var(--border);
      border-radius:var(--radius);padding:24px;margin-bottom:30px;">
      <h3 style="font-weight:600;margin-bottom:16px;display:flex;align-items:center;gap:10px;">
        <div style="width:8px;height:8px;background:var(--success);border-radius:50%;animation:pulse 2s ease-in-out infinite;"></div>
        ${APP.room.participants.length} ${APP.room.participants.length === 1 ? 'person' : 'people'} in room
      </h3>
      
      ${APP.room.participants.map(p => `
        <div style="display:flex;justify-content:space-between;align-items:center;
          background:var(--surface-2);border-radius:10px;padding:14px;margin-bottom:10px;">
          <div style="display:flex;align-items:center;gap:12px;">
            <div style="font-size:1.8rem;">${escapeHtml(p.avatar)}</div>
            <div>
              <div style="font-weight:600;">${escapeHtml(p.name)}</div>
              ${p.isHost ? '<span style="background:var(--accent);color:var(--bg);padding:2px 8px;border-radius:8px;font-size:0.7rem;font-weight:700;">HOST</span>' : ''}
            </div>
          </div>
          <div style="color:var(--success);">âœ“</div>
        </div>
      `).join('')}
    </div>

    ${isHost ? `
      <h3 style="text-align:center;font-family:'Fraunces',serif;font-size:1.5rem;margin-bottom:20px;">
        Choose Activity
      </h3>
      
      <div class="grid-2">
        <button type="button" class="card" data-action="start-lightning-trivia" aria-label="Start Lightning Trivia">
          <div class="card-icon">âš¡</div>
          <h3 class="card-title">Lightning Trivia</h3>
          <p class="card-desc">Kahoot-style quiz with 20s timer & speed scoring</p>
        </button>

        <button type="button" class="card" data-action="start-emoji-charades" aria-label="Start Emoji Charades">
          <div class="card-icon">ğŸ­</div>
          <h3 class="card-title">Emoji Charades</h3>
          <p class="card-desc">Guess the phrase behind each emoji clue</p>
        </button>
        
        <button type="button" class="card" data-action="start-icebreaker" aria-label="Start Icebreaker Roulette">
          <div class="card-icon">ğŸ²</div>
          <h3 class="card-title">Icebreaker Roulette</h3>
          <p class="card-desc">Fun questions to spark great conversations</p>
        </button>
        
        <button type="button" class="card" data-action="start-pulse-check" aria-label="Start Team Pulse Check">
          <div class="card-icon">ğŸ“Š</div>
          <h3 class="card-title">Team Pulse Check</h3>
          <p class="card-desc">Quick polls to gauge team sentiment</p>
        </button>
        
        <button type="button" class="card" data-action="start-values-vote" aria-label="Start Values Vote">
          <div class="card-icon">â­</div>
          <h3 class="card-title">Values Vote</h3>
          <p class="card-desc">Discover what matters most to your team</p>
        </button>
        
        <button type="button" class="card" data-action="start-wordle" aria-label="Start Team Wordle">
          <div class="card-icon">ğŸ¯</div>
          <h3 class="card-title">Team Wordle</h3>
          <p class="card-desc">Guess the 5-letter word together</p>
        </button>

        <button type="button" class="card" data-action="start-word-chain" aria-label="Start Word Chain">
          <div class="card-icon">ğŸ”—</div>
          <h3 class="card-title">Word Chain</h3>
          <p class="card-desc">Solve 5 hidden compound words with the fewest tries</p>
        </button>

        <button type="button" class="card" data-action="start-brainstorm-canvas" aria-label="Start Brainstorm Canvas">
          <div class="card-icon">ğŸ§©</div>
          <h3 class="card-title">Brainstorm Canvas</h3>
          <p class="card-desc">Add sticky notes and vote in Start / Stop / Improve / Create</p>
        </button>

        <!-- Activity Queue button removed from Choose Activity menu -->
        
        <button type="button" class="card" data-action="start-regular-trivia" aria-label="Start Trivia Battle">
          <div class="card-icon">ğŸ§ </div>
          <h3 class="card-title">Trivia Battle</h3>
          <p class="card-desc">Compete with classic trivia questions</p>
        </button>
      </div>
    ` : `
      <div style="text-align:center;padding:60px 20px;">
        <div style="width:48px;height:48px;margin:0 auto 20px;border:4px solid var(--surface-2);
          border-top:4px solid var(--accent);border-radius:50%;animation:spin 1s linear infinite;"></div>
        <p style="color:var(--text-dim);">Waiting for host to start an activity...</p>
      </div>
    `}
  `;
}

function renderActivityQueue() {
  const isHost = APP.room.host === APP.player.name;
  const safeRoomCode = escapeHtml(APP.roomCode);
  const activityQueue = Array.isArray(APP.room.activityQueue) ? APP.room.activityQueue : [];
  const queueIndex = Number.isInteger(APP.room.queueIndex) ? APP.room.queueIndex : 0;
  const queueActive = Boolean(APP.room.queueActive);
  const queueRemaining = activityQueue.slice(queueIndex);

  return `
    <div class="header">
      <h1 class="logo">Activity Queue</h1>
      <p class="tagline">Room: ${safeRoomCode}</p>
    </div>

    <button class="btn-secondary" data-action="go-screen" data-screen="lobby">â† Back to Lobby</button>

    <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:var(--radius);padding:20px;margin-top:16px;">
      <h3 style="font-weight:700;margin-bottom:12px;">Queued Activities</h3>
      ${activityQueue.length ? `
        <div style="margin-bottom:12px;">
          ${activityQueue.map((activityId, idx) => {
            const item = ACTIVITY_QUEUE_ITEM_MAP[activityId];
            if (!item) return '';
            const isCurrentPointer = queueActive && idx === queueIndex;
            const isDone = idx < queueIndex;
            const bg = isDone ? 'rgba(0,210,106,0.06)' : (isCurrentPointer ? 'rgba(0,210,211,0.08)' : 'var(--surface-2)');
            const border = isCurrentPointer ? 'var(--accent)' : 'var(--border)';
            return `
              <div style="display:flex;justify-content:space-between;align-items:center;background:${bg};
                border:1px solid ${border};border-radius:10px;padding:10px 12px;margin-bottom:8px;">
                <div style="display:flex;align-items:center;gap:10px;">
                  <span style="font-weight:700;min-width:20px;">${idx + 1}.</span>
                  <span>${item.icon}</span>
                  <span>${escapeHtml(item.label)}</span>
                  ${isCurrentPointer ? '<span style="font-size:0.75rem;color:var(--accent);font-weight:700;">UP NEXT</span>' : ''}
                  ${isDone ? '<span style="font-size:0.75rem;color:var(--success);font-weight:700;">DONE</span>' : ''}
                </div>
                ${isHost ? `<button class="btn-secondary" data-action="queue-remove" data-queue-index="${idx}" style="padding:6px 10px;">Remove</button>` : ''}
              </div>
            `;
          }).join('')}
        </div>
      ` : `
        <div style="color:var(--text-dim);margin-bottom:12px;">No activities queued yet.</div>
      `}
      <div style="font-size:0.85rem;color:var(--text-dim);margin-bottom:10px;">
        ${queueActive
          ? (queueRemaining.length ? `${queueRemaining.length} remaining in queue` : 'Queue will complete after this activity')
          : 'Queue is paused'}
      </div>

      ${isHost ? `
        <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;margin-bottom:12px;">
          ${ACTIVITY_QUEUE_ITEMS.map(item => `
            <button class="btn-secondary" data-action="queue-add" data-activity="${item.id}" style="padding:10px 12px;">
              ${item.icon} ${escapeHtml(item.label)}
            </button>
          `).join('')}
        </div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <button class="btn-primary" data-action="queue-start" style="width:auto;padding:10px 14px;">Start Queue</button>
          <button class="btn-secondary" data-action="queue-next">Next in Queue</button>
          <button class="btn-secondary" data-action="queue-clear">Clear Queue</button>
        </div>
      ` : ''}
    </div>
  `;
}

function renderHostSettingsModal() {
  const roomSettings = getRoomHostSettings(APP.room);
  const activeTab = APP.hostSettingsTab || 'game';
  return `
    <div style="position:fixed;inset:0;background:rgba(0,0,0,0.55);z-index:10020;display:grid;place-items:center;padding:16px;">
      <div style="width:min(760px,100%);max-height:90vh;overflow:auto;background:var(--surface-solid);
        border:1px solid var(--border);border-radius:16px;padding:22px;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:14px;">
          <h3 style="font-family:'Fraunces',serif;font-size:1.4rem;">Host Settings</h3>
          <button class="btn-secondary" data-action="close-host-settings">Close</button>
        </div>

        <div class="host-tabs" role="tablist" aria-label="Host settings sections">
          <button class="host-tab-btn ${activeTab === 'game' ? 'active' : ''}" data-action="host-settings-tab" data-tab="game" role="tab" aria-selected="${activeTab === 'game' ? 'true' : 'false'}">
            Game Rules
          </button>
          <button class="host-tab-btn ${activeTab === 'ai' ? 'active' : ''}" data-action="host-settings-tab" data-tab="ai" role="tab" aria-selected="${activeTab === 'ai' ? 'true' : 'false'}">
            AI Settings
          </button>
        </div>

        <div data-tab-panel="game" class="host-tab-panel" ${activeTab !== 'game' ? 'hidden' : ''} style="margin-bottom:18px;">
          <h4 style="margin-bottom:10px;">Game Toggles (Room-wide)</h4>
          <label style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
            <input type="checkbox" id="hsAutoRevealLightning" ${roomSettings.autoRevealLightning ? 'checked' : ''}>
            Auto-reveal Lightning answers (all answered or timer ends)
          </label>
          <label style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
            <input type="checkbox" id="hsAllowAnswerChanges" ${roomSettings.allowAnswerChanges ? 'checked' : ''}>
            Allow answer changes before reveal
          </label>
          <label style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
            <input type="checkbox" id="hsDynamicScoring" ${roomSettings.dynamicScoring ? 'checked' : ''}>
            Dynamic time-based scoring
          </label>
          <label style="display:flex;align-items:center;gap:8px;">
            <input type="checkbox" id="hsEnableAIGenerator" ${roomSettings.enableAIGenerator ? 'checked' : ''}>
            Enable AI Content Generator
          </label>
        </div>

        <div data-tab-panel="ai" class="host-tab-panel" ${activeTab !== 'ai' ? 'hidden' : ''} style="margin-bottom:18px;">
          <h4 style="margin-bottom:10px;">AI Configuration (Host Local)</h4>
          <div class="form-group">
            <label class="form-label" for="hsAiEndpoint">Endpoint</label>
            <input id="hsAiEndpoint" class="form-input" value="${escapeHtml(HOST_LOCAL_CONFIG.aiEndpoint)}" placeholder="https://api.openai.com/v1/chat/completions">
          </div>
          <div class="form-group">
            <label class="form-label" for="hsAiModel">Model</label>
            <input id="hsAiModel" class="form-input" value="${escapeHtml(HOST_LOCAL_CONFIG.aiModel)}" placeholder="gpt-4o-mini">
          </div>
          <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;">
            <div class="form-group">
              <label class="form-label" for="hsAiDefaultActivity">Default Activity</label>
              <select id="hsAiDefaultActivity" class="form-input">
                ${AI_GENERATION_TARGETS.map(item => `
                  <option value="${item.id}" ${HOST_LOCAL_CONFIG.aiDefaultActivity === item.id ? 'selected' : ''}>${escapeHtml(item.label)}</option>
                `).join('')}
              </select>
            </div>
            <div class="form-group">
              <label class="form-label" for="hsAiDefaultDifficulty">Default Difficulty</label>
              <select id="hsAiDefaultDifficulty" class="form-input">
                <option value="easy" ${HOST_LOCAL_CONFIG.aiDefaultDifficulty === 'easy' ? 'selected' : ''}>Easy</option>
                <option value="mixed" ${HOST_LOCAL_CONFIG.aiDefaultDifficulty === 'mixed' ? 'selected' : ''}>Mixed</option>
                <option value="hard" ${HOST_LOCAL_CONFIG.aiDefaultDifficulty === 'hard' ? 'selected' : ''}>Hard</option>
              </select>
            </div>
            <div class="form-group">
              <label class="form-label" for="hsAiDefaultCount">Default Count</label>
              <input id="hsAiDefaultCount" class="form-input" type="number" min="3" max="20" value="${HOST_LOCAL_CONFIG.aiDefaultCount}">
            </div>
          </div>
          <div class="form-group">
            <label class="form-label" for="hsAiApiKey">API Key</label>
            <input id="hsAiApiKey" class="form-input" type="password" value="${escapeHtml(HOST_LOCAL_CONFIG.aiApiKey)}" placeholder="Optional fallback. Preferred: server env CHAT_GPT_MINI_KEY">
          </div>

          ${roomSettings.enableAIGenerator ? `
            <div style="margin-top:10px;padding-top:10px;border-top:1px solid var(--border);">
              <h4 style="margin-bottom:10px;">ğŸ¤– AI Content Generator</h4>
              <div style="display:grid;grid-template-columns:1.2fr 2fr 1fr 1fr;gap:10px;margin-bottom:10px;">
                <select id="aiActivity" class="form-input">
                  ${AI_GENERATION_TARGETS.map(item => `
                    <option value="${item.id}" ${HOST_LOCAL_CONFIG.aiDefaultActivity === item.id ? 'selected' : ''}>${escapeHtml(item.label)}</option>
                  `).join('')}
                </select>
                <input id="aiTopic" class="form-input" placeholder="Topic or focus (e.g., Sprint Retro, Space, Leadership)">
                <select id="aiDifficulty" class="form-input">
                  <option value="easy" ${HOST_LOCAL_CONFIG.aiDefaultDifficulty === 'easy' ? 'selected' : ''}>Easy</option>
                  <option value="mixed" ${HOST_LOCAL_CONFIG.aiDefaultDifficulty === 'mixed' ? 'selected' : ''}>Mixed</option>
                  <option value="hard" ${HOST_LOCAL_CONFIG.aiDefaultDifficulty === 'hard' ? 'selected' : ''}>Hard</option>
                </select>
                <input id="aiCount" class="form-input" type="number" min="3" max="20" value="${HOST_LOCAL_CONFIG.aiDefaultCount}" placeholder="Count">
              </div>
              <input id="aiApiKey" class="form-input" type="password" value="${escapeHtml(HOST_LOCAL_CONFIG.aiApiKey)}" placeholder="Optional fallback API key (local browser only)" style="margin-bottom:10px;">
              <button class="btn-primary" data-action="generate-ai-questions" ${APP.aiGenerating ? 'disabled' : ''}>
                ${APP.aiGenerating ? 'Generating...' : 'Generate & Add Content'}
              </button>
              <div style="margin-top:8px;font-size:0.85rem;color:var(--text-dim);">
                Uses server-side AI key from <code>CHAT_GPT_MINI_KEY</code> when configured. Supported targets: Lightning Trivia, Emoji Charades, Trivia Battle, Icebreaker, Team Pulse, Values Vote, Team Wordle, Word Chain, Brainstorm Canvas.
              </div>
              ${APP.aiStatus ? `<div role="status" aria-live="polite" style="margin-top:10px;color:var(--text-mid);font-size:0.9rem;">${escapeHtml(APP.aiStatus)}</div>` : ''}
            </div>
          ` : `
            <div style="margin-top:10px;color:var(--text-dim);font-size:0.9rem;">
              AI Content Generator is disabled. Enable it above to generate content here.
            </div>
          `}
        </div>

        <button class="btn-primary" data-action="save-host-settings">Save Host Settings</button>
      </div>
    </div>
  `;
}

// UI Helper Functions
let selectedAvatar = getRandomAvatar();
let selectedEditAvatar = null;

function selectAvatar(av) {
  selectedAvatar = av;
  document.querySelectorAll('[id^="av-"]').forEach(btn => {
    btn.style.borderColor = 'var(--border)';
    btn.classList.remove('selected');
  });
  const btn = document.getElementById('av-' + av);
  if (btn) {
    btn.style.borderColor = 'var(--accent)';
    btn.classList.add('selected');
  }
}

function selectEditAvatar(av) {
  selectedEditAvatar = av;
  document.querySelectorAll('[id^="edit-av-"]').forEach(btn => {
    btn.style.borderColor = 'var(--border)';
    btn.classList.remove('selected');
  });
  const btn = document.getElementById('edit-av-' + av);
  if (btn) {
    btn.style.borderColor = 'var(--accent)';
    btn.classList.add('selected');
  }
  const emojiInput = document.getElementById('editEmoji');
  if (emojiInput) emojiInput.value = av;
}

function togglePresentation() {
  APP.presentationMode = !APP.presentationMode;
  document.body.classList.toggle('presentation-mode', APP.presentationMode);
  
  const btn = document.getElementById('presentationToggle');
  if (btn) {
    btn.textContent = APP.presentationMode ? 'ğŸ“± Exit Presentation' : 'ğŸ“º Presentation Mode';
  }
  
  render();
}

async function createPlayer() {
  const name = normalizeName(document.getElementById('playerName')?.value || '');
  if (!name) {
    showError('Please enter your name');
    return;
  }
  
  const avatar = AVATAR_OPTIONS.includes(selectedAvatar) ? selectedAvatar : getRandomAvatar();
  APP.player = await PlayerManager.createProfile(name, avatar);
  APP.screen = APP.pendingJoinCode ? 'join-room' : 'dashboard';
  render();
}

async function copyJoinLink() {
  if (!APP.roomCode) return;
  const joinUrl = `${window.location.origin}${window.location.pathname}?join=${encodeURIComponent(APP.roomCode)}`;
  try {
    if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(joinUrl);
      showError('Join link copied.');
      return;
    }
  } catch (_error) {
    // fallback below
  }
  const fallback = document.createElement('textarea');
  fallback.value = joinUrl;
  fallback.setAttribute('readonly', 'true');
  fallback.style.position = 'fixed';
  fallback.style.left = '-9999px';
  document.body.appendChild(fallback);
  fallback.select();
  document.execCommand('copy');
  fallback.remove();
  showError('Join link copied.');
}

function goToScreen(screen) {
  const roomScreens = new Set(['lobby', 'activity-queue']);
  if (!roomScreens.has(screen)) {
    stopRoomSync();
    APP.showHostSettings = false;
    resetWordChainFocusState();
  }
  APP.screen = screen;
  
  if (screen === 'create-room') {
    createRoomAndNavigate();
  } else {
    render();
  }
}

async function startRoomRealtime() {
  roomRealtimeEnabled = false;
  if (!APP.roomCode) return false;

  const sharedKey = `room:${APP.roomCode}`;

  const socket = await getSocketClient();
  if (socket && socket.connected) {
    socketRoomKey = sharedKey;
    socket.emit('room:subscribe', sharedKey);
    roomRealtimeEnabled = true;
    return true;
  }

  const client = await getSupabaseClient();
  if (!client) return false;

  if (roomChannel) {
    await client.removeChannel(roomChannel);
    roomChannel = null;
  }

  roomChannel = client
    .channel(`room-sync-${APP.roomCode}`)
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'shared_state',
        filter: `key=eq.${sharedKey}`
      },
      payload => {
        const value = payload.new?.value || payload.old?.value;
        const room = safeParseJson(value);
        if (room) {
          APP.room = room;
          render();
        }
      }
    )
    .subscribe(status => {
      roomRealtimeEnabled = status === 'SUBSCRIBED';
    });

  return true;
}

async function stopRoomRealtime() {
  const socket = await getSocketClient();
  if (socket && socket.connected && socketRoomKey) {
    socket.emit('room:unsubscribe', socketRoomKey);
    socketRoomKey = null;
  }

  const client = await getSupabaseClient();
  if (client && roomChannel) {
    await client.removeChannel(roomChannel);
    roomChannel = null;
  }
  roomRealtimeEnabled = false;
}

function stopRoomSync() {
  if (syncInterval) {
    clearInterval(syncInterval);
    syncInterval = null;
  }
  stopRoomRealtime();
}

async function createRoomAndNavigate() {
  render();
  
  const room = await RoomManager.createRoom(APP.player.name, APP.player.avatar);
  APP.room = room;
  APP.roomCode = room.code;
  APP.screen = 'lobby';
  
  startRoomSync();
  render();
}

async function joinRoom() {
  const code = normalizeRoomCode(document.getElementById('joinCode')?.value || '');
  if (!/^[A-Z0-9]{6}$/.test(code || '')) {
    showError('Please enter a valid 6-digit room code');
    return;
  }
  
  const room = await RoomManager.joinRoom(code, APP.player.name, APP.player.avatar);
  if (!room) {
    showError('Room not found. Check the code.');
    return;
  }
  
  APP.room = room;
  APP.roomCode = code;
  APP.pendingJoinCode = '';
  APP.screen = 'lobby';
  
  startRoomSync();
  render();
}

async function leaveSession() {
  if (!APP.roomCode || !APP.player?.name) {
    APP.room = null;
    APP.roomCode = null;
    APP.showHostSettings = false;
    APP.screen = 'dashboard';
    stopRoomSync();
    resetWordChainFocusState();
    render();
    return;
  }

  const confirmed = window.confirm('Leave this session?');
  if (!confirmed) return;

  const room = await RoomManager.loadRoom(APP.roomCode);
  if (room) {
    room.participants = (room.participants || []).filter(p => p.name !== APP.player.name);
    if (room.participants.length > 0) {
      if (room.host === APP.player.name) {
        room.host = room.participants[0].name;
      }
      room.participants = room.participants.map(p => ({
        ...p,
        isHost: p.name === room.host
      }));
    } else {
      room.host = null;
      room.currentActivity = null;
      room.activityState = {};
    }
    await RoomManager.updateRoom(APP.roomCode, room);
  }

  stopRoomSync();
  APP.room = null;
  APP.roomCode = null;
  APP.showHostSettings = false;
  APP.screen = 'dashboard';
  resetWordChainFocusState();
  render();
}

function startRoomSync() {
  if (syncInterval) clearInterval(syncInterval);
  startRoomRealtime();
  syncInterval = setInterval(async () => {
    if (!APP.roomCode) return;
    if (!roomRealtimeEnabled) {
      const room = await RoomManager.loadRoom(APP.roomCode);
      if (room && room.lastUpdate !== APP.room?.lastUpdate) {
        APP.room = room;
        render();
      }
    }
    
    // Update timer during active questions
    if (APP.room?.currentActivity === 'lightning-trivia' && !APP.room?.activityState?.revealed) {
      const state = APP.room.activityState || {};
      const hostSettings = getRoomHostSettings(APP.room);
      const answersCount = Object.keys(state.answers || {}).length;
      const participantCount = APP.room.participants?.length || 0;
      const allAnswered = participantCount > 0 && answersCount >= participantCount;
      const startTime = state.startTime || Date.now();
      const timedOut = Date.now() - startTime >= 20000;
      const isHost = APP.room.host === APP.player?.name;

      if (hostSettings.autoRevealLightning && isHost && !lightningAutoRevealPending && (allAnswered || timedOut)) {
        lightningAutoRevealPending = true;
        try {
          await revealAnswer();
        } finally {
          lightningAutoRevealPending = false;
        }
      }
      render();
    }
  }, ROOM_SYNC_MS);
}

function showError(msg) {
  APP.error = msg;
  render();
  setTimeout(() => {
    APP.error = null;
    render();
  }, 3000);
}

function resetWordChainFocusState() {
  wordChainLastAutoFocusKey = '';
  if (wordChainFocusCueTimer) {
    clearTimeout(wordChainFocusCueTimer);
    wordChainFocusCueTimer = null;
  }
}

function normalizePresentationUrl(value) {
  const raw = String(value || '').trim();
  if (!raw) return '';
  try {
    const withProtocol = /^https?:\/\//i.test(raw) ? raw : `https://${raw}`;
    const parsed = new URL(withProtocol);
    if (!['http:', 'https:'].includes(parsed.protocol)) return '';
    return parsed.toString();
  } catch (_error) {
    return '';
  }
}

async function saveSharedPresentation() {
  if (!APP.roomCode || !APP.room || APP.room.host !== APP.player?.name) return;
  const title = String(document.getElementById('presentationTitle')?.value || '').trim().slice(0, 120);
  const url = normalizePresentationUrl(document.getElementById('presentationUrl')?.value || '');
  if (!url) {
    showError('Enter a valid presentation URL.');
    return;
  }

  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room) {
    showError('Room no longer available.');
    return;
  }
  room.sharedPresentation = {
    title: title || 'Shared Presentation',
    url,
    sharedBy: APP.player.name,
    updatedAt: Date.now()
  };
  await RoomManager.updateRoom(APP.roomCode, room);
  APP.room = room;
  render();
}

async function clearSharedPresentation() {
  if (!APP.roomCode || !APP.room || APP.room.host !== APP.player?.name) return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room) {
    showError('Room no longer available.');
    return;
  }
  delete room.sharedPresentation;
  await RoomManager.updateRoom(APP.roomCode, room);
  APP.room = room;
  render();
}

function openSharedPresentation() {
  const url = APP.room?.sharedPresentation?.url;
  if (!url) {
    showError('No shared presentation link is available.');
    return;
  }
  window.open(url, '_blank', 'noopener,noreferrer');
}

async function queueAddActivity(activityId) {
  if (!APP.roomCode || !APP.room || APP.room.host !== APP.player?.name) return;
  if (!ACTIVITY_QUEUE_ITEM_MAP[activityId]) return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room) {
    showError('Room no longer available.');
    return;
  }
  room.activityQueue = Array.isArray(room.activityQueue) ? room.activityQueue : [];
  room.activityQueue.push(activityId);
  if (!Number.isInteger(room.queueIndex)) room.queueIndex = 0;
  if (typeof room.queueActive !== 'boolean') room.queueActive = false;
  await RoomManager.updateRoom(APP.roomCode, room);
  APP.room = room;
  render();
}

async function queueRemoveActivityAt(index) {
  if (!APP.roomCode || !APP.room || APP.room.host !== APP.player?.name) return;
  if (!Number.isInteger(index) || index < 0) return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room) {
    showError('Room no longer available.');
    return;
  }
  room.activityQueue = Array.isArray(room.activityQueue) ? room.activityQueue : [];
  if (index >= room.activityQueue.length) return;
  room.activityQueue.splice(index, 1);
  room.queueIndex = Math.max(0, Math.min(room.queueIndex || 0, room.activityQueue.length));
  if (!room.activityQueue.length) {
    room.queueActive = false;
    room.queueIndex = 0;
  }
  await RoomManager.updateRoom(APP.roomCode, room);
  APP.room = room;
  render();
}

async function queueClearAll() {
  if (!APP.roomCode || !APP.room || APP.room.host !== APP.player?.name) return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room) {
    showError('Room no longer available.');
    return;
  }
  room.activityQueue = [];
  room.queueIndex = 0;
  room.queueActive = false;
  await RoomManager.updateRoom(APP.roomCode, room);
  APP.room = room;
  render();
}

async function queueStartRun() {
  if (!APP.roomCode || !APP.room || APP.room.host !== APP.player?.name) return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room) {
    showError('Room no longer available.');
    return;
  }
  room.activityQueue = Array.isArray(room.activityQueue) ? room.activityQueue : [];
  if (!room.activityQueue.length) {
    showError('Add at least one activity to the queue.');
    return;
  }
  room.queueActive = true;
  room.queueIndex = 0;
  await RoomManager.updateRoom(APP.roomCode, room);
  APP.room = room;
  await runNextQueuedActivity(room);
}

async function queueNextActivity() {
  if (!APP.roomCode || !APP.room || APP.room.host !== APP.player?.name) return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room) {
    showError('Room no longer available.');
    return;
  }
  room.activityQueue = Array.isArray(room.activityQueue) ? room.activityQueue : [];
  if (!room.activityQueue.length) {
    showError('Queue is empty.');
    return;
  }
  room.queueActive = true;
  await RoomManager.updateRoom(APP.roomCode, room);
  APP.room = room;
  await runNextQueuedActivity(room);
}

function viewStats() {
  APP.screen = 'about';
  render();
}

async function loadPublicConfig() {
  try {
    const data = await apiRequest('/api/config');
    applyBranding(data.config || {});
  } catch (e) {
    console.warn('Failed to load config:', e.message);
  }
}

async function openFeedbackHub() {
  if (APP.preferences.enableFeedbackHub === false) {
    showError('Feedback Hub is currently disabled by admin.');
    return;
  }
  APP.screen = 'feedback';
  APP.feedbackLoading = true;
  APP.feedback = [];
  render();
  await refreshMyFeedback();
}

async function refreshMyFeedback() {
  APP.feedbackLoading = true;
  render();
  try {
    const data = await apiRequest('/api/feedback/mine', { withUserToken: true });
    APP.feedback = Array.isArray(data.feedback) ? data.feedback : [];
  } catch (e) {
    showError(e.message);
  } finally {
    APP.feedbackLoading = false;
    render();
  }
}

async function submitFeedback() {
  const type = String(document.getElementById('feedbackType')?.value || 'general');
  const title = String(document.getElementById('feedbackTitle')?.value || '').trim();
  const details = String(document.getElementById('feedbackDetails')?.value || '').trim();
  if (!title || !details) {
    showError('Title and details are required.');
    return;
  }
  try {
    await apiRequest('/api/feedback', {
      method: 'POST',
      withUserToken: true,
      body: {
        type,
        title,
        details,
        userName: APP.player?.name || 'Anonymous',
        userId: APP.player?.id || ''
      }
    });
    const titleInput = document.getElementById('feedbackTitle');
    const detailsInput = document.getElementById('feedbackDetails');
    if (titleInput) titleInput.value = '';
    if (detailsInput) detailsInput.value = '';
    await refreshMyFeedback();
  } catch (e) {
    showError(e.message);
  }
}

function openAdminConsole() {
  APP.screen = 'admin';
  render();
}

async function adminLogin() {
  const tokenInput = document.getElementById('adminToken');
  const token = String(tokenInput?.value || APP.admin.token || '').trim();
  if (!token) {
    showError('Admin token is required.');
    return;
  }
  APP.admin.token = token;
  localStorage.setItem('admin-token', token);
  try {
    await apiRequest('/api/admin/login', {
      method: 'POST',
      adminToken: token
    });
    APP.admin.authenticated = true;
    await refreshAdminConfig();
    await refreshAdminFeedback();
  } catch (e) {
    APP.admin.authenticated = false;
    showError(e.message);
    render();
  }
}

function adminLogout() {
  APP.admin.authenticated = false;
  APP.admin.feedback = [];
  APP.admin.loading = false;
  localStorage.removeItem('admin-token');
  APP.admin.token = '';
  render();
}

async function refreshAdminConfig() {
  if (!APP.admin.authenticated || !APP.admin.token) return;
  try {
    const data = await apiRequest('/api/admin/config', { adminToken: APP.admin.token });
    applyBranding(data.config || {});
  } catch (e) {
    showError(e.message);
  }
}

async function refreshAdminFeedback() {
  if (!APP.admin.authenticated || !APP.admin.token) return;
  APP.admin.loading = true;
  render();
  try {
    const data = await apiRequest('/api/admin/feedback', { adminToken: APP.admin.token });
    APP.admin.feedback = Array.isArray(data.feedback) ? data.feedback : [];
  } catch (e) {
    showError(e.message);
  } finally {
    APP.admin.loading = false;
    render();
  }
}

async function saveAdminFeedbackItem(feedbackId) {
  if (!feedbackId || !APP.admin.authenticated) return;
  const status = String(document.getElementById(`admin-status-${feedbackId}`)?.value || 'open');
  const adminNotes = String(document.getElementById(`admin-notes-${feedbackId}`)?.value || '');
  try {
    await apiRequest(`/api/admin/feedback/${feedbackId}`, {
      method: 'PATCH',
      adminToken: APP.admin.token,
      body: { status, adminNotes }
    });
    await refreshAdminFeedback();
  } catch (e) {
    showError(e.message);
  }
}

async function saveAdminConfig() {
  if (!APP.admin.authenticated) return;
  const appName = String(document.getElementById('adminBrandAppName')?.value || '').trim();
  const tagline = String(document.getElementById('adminBrandTagline')?.value || '').trim();
  const accent = String(document.getElementById('adminBrandAccent')?.value || '').trim();
  const enableFeedbackHub = Boolean(document.getElementById('adminEnableFeedbackHub')?.checked);

  try {
    const data = await apiRequest('/api/admin/config', {
      method: 'PUT',
      adminToken: APP.admin.token,
      body: {
        branding: { appName, tagline, accent },
        preferences: { enableFeedbackHub }
      }
    });
    applyBranding(data.config || {});
    render();
  } catch (e) {
    showError(e.message);
  }
}

function openHostSettings() {
  if (!APP.room || APP.room.host !== APP.player?.name) return;
  APP.hostSettingsTab = 'game';
  APP.showHostSettings = true;
  render();
}

function closeHostSettings() {
  APP.showHostSettings = false;
  render();
}

function switchHostSettingsTab(tabId) {
  if (!APP.showHostSettings) return;
  const allowedTabs = new Set(['game', 'ai']);
  const nextTab = allowedTabs.has(tabId) ? tabId : 'game';
  APP.hostSettingsTab = nextTab;

  const tabButtons = document.querySelectorAll('.host-tab-btn');
  const tabPanels = document.querySelectorAll('.host-tab-panel');
  if (!tabButtons.length || !tabPanels.length) {
    render();
    return;
  }

  tabButtons.forEach(button => {
    const isActive = button.dataset.tab === nextTab;
    button.classList.toggle('active', isActive);
    button.setAttribute('aria-selected', isActive ? 'true' : 'false');
  });

  tabPanels.forEach(panel => {
    panel.hidden = panel.getAttribute('data-tab-panel') !== nextTab;
  });
}

async function saveHostSettings() {
  if (!APP.room || APP.room.host !== APP.player?.name) return;

  const roomSettings = {
    autoRevealLightning: Boolean(document.getElementById('hsAutoRevealLightning')?.checked),
    allowAnswerChanges: Boolean(document.getElementById('hsAllowAnswerChanges')?.checked),
    dynamicScoring: Boolean(document.getElementById('hsDynamicScoring')?.checked),
    enableAIGenerator: Boolean(document.getElementById('hsEnableAIGenerator')?.checked)
  };

  HOST_LOCAL_CONFIG = {
    ...HOST_LOCAL_CONFIG,
    aiEndpoint: (document.getElementById('hsAiEndpoint')?.value || '').trim() || getDefaultHostLocalConfig().aiEndpoint,
    aiModel: (document.getElementById('hsAiModel')?.value || '').trim() || getDefaultHostLocalConfig().aiModel,
    aiDefaultActivity: AI_GENERATION_TARGET_LABELS[document.getElementById('hsAiDefaultActivity')?.value || '']
      ? String(document.getElementById('hsAiDefaultActivity')?.value || '')
      : getDefaultHostLocalConfig().aiDefaultActivity,
    aiDefaultDifficulty: String(document.getElementById('hsAiDefaultDifficulty')?.value || 'mixed'),
    aiDefaultCount: Math.max(3, Math.min(20, Number.parseInt(document.getElementById('hsAiDefaultCount')?.value || '8', 10) || 8)),
    aiApiKey: (document.getElementById('hsAiApiKey')?.value || '').trim()
  };
  localStorage.setItem('ai-question-api-key', HOST_LOCAL_CONFIG.aiApiKey || '');
  saveHostLocalConfig(HOST_LOCAL_CONFIG);

  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room) {
    showError('Room no longer available.');
    return;
  }
  room.hostSettings = roomSettings;
  await RoomManager.updateRoom(APP.roomCode, room);
  APP.room = room;
  APP.showHostSettings = false;
  render();
}

function buildAIPromptForActivity(activityId, topic, difficulty, count) {
  const targetTopic = topic || 'team collaboration';
  switch (activityId) {
    case 'lightning-trivia':
    case 'regular-trivia':
      return `Generate ${count} multiple-choice trivia questions about "${targetTopic}" at ${difficulty} difficulty.
Return only valid JSON as an array. Each item must be:
{"q":"question text","opts":["A","B","C","D"],"ans":0}
where ans is the zero-based index of the correct option.`;
    case 'icebreaker':
      return `Generate ${count} icebreaker prompts about "${targetTopic}" at ${difficulty} difficulty.
Return only valid JSON as an array of strings.`;
    case 'emoji-charades':
      return `Generate ${count} emoji charades prompts about "${targetTopic}" at ${difficulty} difficulty.
Return only valid JSON as an array. Each item must be:
{"emojis":"emoji sequence","answer":"short phrase answer"}`;
    case 'pulse-check':
      return `Generate ${count} pulse-check polls about "${targetTopic}" for a team session.
Return only valid JSON as an array. Each item must be:
{"q":"question text","opts":["Option 1","Option 2","Option 3","Option 4"]}`;
    case 'values-vote':
      return `Generate ${count} team values themed around "${targetTopic}".
Return only valid JSON as an array. Each item must be:
{"name":"short value name","icon":"emoji"}`;
    case 'wordle':
      return `Generate ${count} distinct single English words related to "${targetTopic}".
Rules: exactly 5 letters, uppercase alphabetic only, no spaces, no punctuation.
Return only valid JSON as an array of strings.`;
    case 'word-chain':
      return `Generate ${Math.max(1, Math.min(5, count))} word-chain puzzles themed around "${targetTopic}".
Rules:
- Each puzzle contains exactly 8 singular words.
- Words use only letters A-Z and each word is 1 to 9 letters.
- Adjacent words should form a common two-word phrase or compound expression.
Return only valid JSON as an array. Each item must be:
{"title":"Chain name","words":["WORD1","WORD2","WORD3","WORD4","WORD5","WORD6","WORD7","WORD8"]}`;
    case 'brainstorm-canvas':
      return `Generate ${count} brainstorming sticky notes for a Start/Stop/Improve/Create retrospective about "${targetTopic}".
Return only valid JSON as an array. Each item must be:
{"text":"short sticky note","lane":"start|stop|improve|create"}`;
    default:
      return '';
  }
}

async function applyAIGeneratedContent(activityId, parsed, topic) {
  if (activityId === 'lightning-trivia' || activityId === 'regular-trivia') {
    const validated = validateAIQuestions(parsed);
    if (!validated.length) throw new Error('AI returned invalid trivia format.');
    TRIVIA_BANK.push(...validated);
    APP.aiStatus = `Added ${validated.length} trivia question${validated.length === 1 ? '' : 's'} for ${AI_GENERATION_TARGET_LABELS[activityId]}. Total trivia questions: ${TRIVIA_BANK.length}.`;
    return;
  }

  if (activityId === 'icebreaker') {
    const validated = validateAIIcebreakerQuestions(parsed);
    if (!validated.length) throw new Error('AI returned invalid icebreaker format.');
    ICEBREAKER_QUESTIONS.push(...validated);
    APP.aiStatus = `Added ${validated.length} icebreaker prompt${validated.length === 1 ? '' : 's'} on "${topic || 'general'}".`;
    return;
  }

  if (activityId === 'emoji-charades') {
    const validated = validateAIEmojiCharades(parsed);
    if (!validated.length) throw new Error('AI returned invalid Emoji Charades format.');
    EMOJI_CHARADES_BANK.push(...validated);
    APP.aiStatus = `Added ${validated.length} Emoji Charades prompt${validated.length === 1 ? '' : 's'}.`;
    return;
  }

  if (activityId === 'pulse-check') {
    const validated = validateAIPulseQuestions(parsed);
    if (!validated.length) throw new Error('AI returned invalid pulse poll format.');
    PULSE_QUESTIONS.push(...validated);
    APP.aiStatus = `Added ${validated.length} pulse poll${validated.length === 1 ? '' : 's'}.`;
    return;
  }

  if (activityId === 'values-vote') {
    const validated = validateAIValues(parsed);
    if (!validated.length) throw new Error('AI returned invalid values format.');
    TEAM_VALUES.push(...validated);
    APP.aiStatus = `Added ${validated.length} value option${validated.length === 1 ? '' : 's'}.`;
    return;
  }

  if (activityId === 'wordle') {
    const validated = validateAIWordleWords(parsed);
    if (!validated.length) throw new Error('AI returned invalid Team Wordle format.');
    WORDLE_WORDS.push(...validated);
    APP.aiStatus = `Added ${validated.length} Team Wordle word${validated.length === 1 ? '' : 's'}.`;
    return;
  }

  if (activityId === 'word-chain') {
    const validated = validateAIWordChainPuzzles(parsed);
    if (!validated.length) throw new Error('AI returned invalid Word Chain puzzle format.');
    WORD_CHAIN_PUZZLES.push(...validated);
    APP.aiStatus = `Added ${validated.length} Word Chain puzzle${validated.length === 1 ? '' : 's'}.`;
    return;
  }

  if (activityId === 'brainstorm-canvas') {
    const validated = validateAIBrainstormNotes(parsed);
    if (!validated.length) throw new Error('AI returned invalid Brainstorm note format.');
    if (!APP.roomCode) throw new Error('Join a room to add brainstorm notes.');
    const room = await RoomManager.loadRoom(APP.roomCode);
    if (!room) throw new Error('Room no longer available.');

    const baseState = (room.currentActivity === 'brainstorm-canvas' && room.activityState && typeof room.activityState === 'object')
      ? room.activityState
      : (room.brainstormData && typeof room.brainstormData === 'object'
        ? room.brainstormData
        : { boardType: 'start-stop-improve-create', notes: [], sessionStatus: 'open', createdAt: Date.now() });
    const notes = Array.isArray(baseState.notes) ? [...baseState.notes] : [];
    const ts = Date.now();
    validated.forEach((item, idx) => {
      notes.unshift({
        id: generateBrainstormNoteId(),
        text: item.text,
        author: 'AI Facilitator',
        lane: item.lane,
        votes: 0,
        voters: [],
        color: BRAINSTORM_NOTE_COLORS[idx % BRAINSTORM_NOTE_COLORS.length],
        createdAt: ts + idx,
        updatedAt: ts + idx
      });
    });

    const nextState = { ...baseState, notes };
    room.brainstormData = safeParseJson(JSON.stringify(nextState)) || nextState;
    room.brainstormLastUpdatedAt = Date.now();
    if (room.currentActivity === 'brainstorm-canvas') {
      room.activityState = nextState;
    }
    await RoomManager.updateRoom(APP.roomCode, room);
    APP.room = room;
    APP.aiStatus = `Added ${validated.length} brainstorm note${validated.length === 1 ? '' : 's'} to the canvas session data.`;
    return;
  }

  throw new Error('Unsupported AI generation target.');
}

async function generateAIQuestions() {
  const activityIdRaw = String(document.getElementById('aiActivity')?.value || HOST_LOCAL_CONFIG.aiDefaultActivity || 'lightning-trivia');
  const activityId = AI_GENERATION_TARGET_LABELS[activityIdRaw] ? activityIdRaw : 'lightning-trivia';
  const topic = normalizeTopic(document.getElementById('aiTopic')?.value || '');
  const difficulty = String(document.getElementById('aiDifficulty')?.value || HOST_LOCAL_CONFIG.aiDefaultDifficulty || 'mixed');
  const count = Math.max(3, Math.min(20, Number.parseInt(document.getElementById('aiCount')?.value || String(HOST_LOCAL_CONFIG.aiDefaultCount || 8), 10) || 8));
  const apiKeyInput = document.getElementById('aiApiKey')?.value?.trim() || '';
  const apiKey = apiKeyInput || HOST_LOCAL_CONFIG.aiApiKey || localStorage.getItem('ai-question-api-key') || '';

  const prompt = buildAIPromptForActivity(activityId, topic, difficulty, count);
  if (!prompt) {
    showError('Unsupported activity selected for AI generation.');
    return;
  }

  APP.aiGenerating = true;
  APP.aiStatus = `Generating ${AI_GENERATION_TARGET_LABELS[activityId] || 'content'}...`;
  render();

  try {
    HOST_LOCAL_CONFIG.aiDefaultActivity = activityId;
    if (apiKey) {
      HOST_LOCAL_CONFIG.aiApiKey = apiKey;
      localStorage.setItem('ai-question-api-key', apiKey);
    }
    saveHostLocalConfig(HOST_LOCAL_CONFIG);
    let textContent = '';
    let serverError = '';
    try {
      const serverData = await apiRequest('/api/ai/generate', {
        method: 'POST',
        body: {
          prompt,
          model: HOST_LOCAL_CONFIG.aiModel,
          temperature: 0.7
        }
      });
      textContent = String(serverData?.content || '');
    } catch (serverErr) {
      serverError = serverErr?.message || 'Server AI generation failed.';
    }

    if (!textContent) {
      if (!apiKey) {
        throw new Error(`${serverError || 'Server AI generation failed.'} Add CHAT_GPT_MINI_KEY on the server or provide an API key in Host Settings.`);
      }

      const response = await fetch(HOST_LOCAL_CONFIG.aiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: HOST_LOCAL_CONFIG.aiModel,
          messages: [
            { role: 'system', content: 'You create accurate facilitator game content. Output strict JSON only.' },
            { role: 'user', content: prompt }
          ],
          temperature: 0.7
        })
      });

      if (!response.ok) {
        const errText = await response.text();
        throw new Error(`AI request failed (${response.status}): ${errText.slice(0, 180)}`);
      }
      const data = await response.json();
      textContent = String(data?.choices?.[0]?.message?.content || '');
    }

    const jsonText = extractFirstJson(textContent);
    const parsed = safeParseJson(jsonText);
    const items = coerceAIArrayPayload(parsed);
    await applyAIGeneratedContent(activityId, items, topic);
  } catch (e) {
    APP.aiStatus = `AI generation failed: ${e.message}`;
  } finally {
    APP.aiGenerating = false;
    render();
  }
}

function showLevelUp(level) {
  APP.error = `Level up! You reached Level ${level}`;
  render();
  setTimeout(() => {
    APP.error = null;
    render();
  }, 2000);
}

function editProfile() {
  selectedEditAvatar = APP.player?.avatar || selectedAvatar;
  APP.editingProfile = true;
  render();
}

function cancelEditProfile() {
  APP.editingProfile = false;
  selectedEditAvatar = null;
  render();
}

function remapActivityStateKey(state, field, oldName, newName) {
  const target = state?.[field];
  if (!target || typeof target !== 'object') return;
  if (!(oldName in target)) return;
  if (newName in target) return;
  target[newName] = target[oldName];
  delete target[oldName];
}

function applyProfileUpdateToRoom(room, oldName, newName, newAvatar) {
  if (!room) return room;

  room.participants = (room.participants || []).map(p => {
    if (p.name !== oldName) return p;
    return { ...p, name: newName, avatar: newAvatar };
  });

  if (room.host === oldName) {
    room.host = newName;
  }

  const state = room.activityState || {};
  remapActivityStateKey(state, 'answers', oldName, newName);
  remapActivityStateKey(state, 'guesses', oldName, newName);
  remapActivityStateKey(state, 'scores', oldName, newName);
  remapActivityStateKey(state, 'votes', oldName, newName);
  remapActivityStateKey(state, 'lastPoints', oldName, newName);
  remapActivityStateKey(state, 'answerTimes', oldName, newName);
  remapActivityStateKey(state, 'entries', oldName, newName);
  remapActivityStateKey(state, 'solved', oldName, newName);
  remapActivityStateKey(state, 'attempts', oldName, newName);
  remapActivityStateKey(state, 'completedAt', oldName, newName);
  remapActivityStateKey(state, 'feedback', oldName, newName);
  remapActivityStateKey(state, 'progressIndex', oldName, newName);
  remapActivityStateKey(state, 'revealedLetters', oldName, newName);
  remapActivityStateKey(state, 'lastLetterGraceUsed', oldName, newName);
  remapActivityStateKey(state, 'solvedWords', oldName, newName);
  remapActivityStateKey(state, 'wordScores', oldName, newName);
  remapActivityStateKey(state, 'wordAttempts', oldName, newName);
  remapActivityStateKey(state, 'totalAttempts', oldName, newName);
  remapActivityStateKey(state, 'chainSuggestions', oldName, newName);
  remapActivityStateKey(state, 'chainVotes', oldName, newName);
  remapActivityStateKey(state, 'wordleVotes', oldName, newName);
  if (Array.isArray(state.notes)) {
    state.notes = state.notes.map(note => {
      const voters = Array.isArray(note.voters)
        ? note.voters.map(voter => (voter === oldName ? newName : voter))
        : [];
      const author = note.author === oldName ? newName : note.author;
      return { ...note, voters, author };
    });
  }
  room.activityState = state;
  if (room.brainstormData && typeof room.brainstormData === 'object' && Array.isArray(room.brainstormData.notes)) {
    room.brainstormData.notes = room.brainstormData.notes.map(note => {
      const voters = Array.isArray(note.voters)
        ? note.voters.map(voter => (voter === oldName ? newName : voter))
        : [];
      const author = note.author === oldName ? newName : note.author;
      return { ...note, voters, author };
    });
  }

  return room;
}

async function saveProfile() {
  if (!APP.player) return;

  const oldName = APP.player.name;
  const updatedName = normalizeName(document.getElementById('editName')?.value || '');
  const typedEmoji = normalizeEmoji(document.getElementById('editEmoji')?.value || '');
  const updatedAvatar = typedEmoji || selectedEditAvatar || APP.player.avatar;
  if (!updatedName) {
    showError('Please enter a valid display name');
    return;
  }

  if (APP.roomCode) {
    const room = await RoomManager.loadRoom(APP.roomCode);
    if (room) {
      const hasConflict = room.participants?.some(p => p.name === updatedName && p.name !== oldName);
      if (hasConflict) {
        showError('That name is already taken in this room.');
        return;
      }
      applyProfileUpdateToRoom(room, oldName, updatedName, updatedAvatar);
      await RoomManager.updateRoom(APP.roomCode, room);
      APP.room = room;
    }
  }

  APP.player.name = updatedName;
  APP.player.avatar = updatedAvatar;
  await PlayerManager.updateProfile(APP.player);

  selectedAvatar = updatedAvatar;

  APP.editingProfile = false;
  selectedEditAvatar = null;
  render();
}

function handleWordleKey(key) {
  const input = document.getElementById('wordleInput');
  if (!input) return;

  const current = normalizeWord(input.value);
  if (key === 'DEL') {
    input.value = current.slice(0, -1);
    return;
  }
  if (key === 'ENTER') {
    submitWordleSuggestion();
    return;
  }
  if (/^[A-Z]$/.test(key) && current.length < 5) {
    input.value = current + key;
  }
}

function getHostTypedWordFromCells() {
  const inputs = Array.from(document.querySelectorAll('.host-wordle-cell-input'))
    .sort((a, b) => Number.parseInt(a.dataset.col || '0', 10) - Number.parseInt(b.dataset.col || '0', 10));
  if (!inputs.length) return '';
  return normalizeWord(inputs.map(input => String(input.value || '').slice(0, 1)).join(''));
}

function captureHostWordleDraft() {
  hostWordleDraft = getHostTypedWordFromCells();
}

function handleWordChainArrowNavigation(event) {
  if (APP.room?.currentActivity !== 'word-chain') return;
  const active = document.activeElement;
  if (!active || !active.classList?.contains('word-chain-letter-input')) return;
  if (event.key === 'Enter') {
    event.preventDefault();
    submitWordChainGuess();
    return;
  }
  const row = Number.parseInt(active.dataset.row || '', 10);
  const pos = Number.parseInt(active.dataset.pos || '', 10);
  if (!Number.isInteger(row) || !Number.isInteger(pos)) return;
  const rowInputs = Array.from(document.querySelectorAll(`.word-chain-letter-input[data-row="${row}"]`))
    .sort((a, b) => Number.parseInt(a.dataset.pos || '0', 10) - Number.parseInt(b.dataset.pos || '0', 10));
  const currentIndex = rowInputs.findIndex(input => input === active);
  if (currentIndex < 0) return;

  if (event.key === 'ArrowLeft' && currentIndex > 0) {
    event.preventDefault();
    rowInputs[currentIndex - 1].focus();
    return;
  }
  if (event.key === 'ArrowRight' && currentIndex < rowInputs.length - 1) {
    event.preventDefault();
    rowInputs[currentIndex + 1].focus();
    return;
  }
  if (event.key === 'Backspace' && !active.value && currentIndex > 0) {
    event.preventDefault();
    rowInputs[currentIndex - 1].focus();
    return;
  }
  if (['ArrowUp', 'ArrowDown'].includes(event.key)) {
    event.preventDefault();
  }
}

function captureWordChainRowDraft(row) {
  const rowInputs = Array.from(document.querySelectorAll(`.word-chain-letter-input[data-row="${row}"]`))
    .sort((a, b) => Number.parseInt(a.dataset.pos || '0', 10) - Number.parseInt(b.dataset.pos || '0', 10));
  wordChainDraft[row] = rowInputs.map(input => normalizeChainWord(input.value).slice(0, 1)).join('');
}

function handleHostWordleCellNavigation(event) {
  const active = document.activeElement;
  if (!active || !active.classList?.contains('host-wordle-cell-input')) return;
  const col = Number.parseInt(active.dataset.col || '', 10);
  if (!Number.isInteger(col)) return;

  if (event.key === 'ArrowLeft' && col > 0) {
    event.preventDefault();
    const prev = document.querySelector(`.host-wordle-cell-input[data-col="${col - 1}"]`);
    if (prev instanceof HTMLInputElement) prev.focus();
    return;
  }
  if (event.key === 'ArrowRight' && col < 4) {
    event.preventDefault();
    const next = document.querySelector(`.host-wordle-cell-input[data-col="${col + 1}"]`);
    if (next instanceof HTMLInputElement) next.focus();
    return;
  }
  if (event.key === 'Backspace' && !active.value && col > 0) {
    event.preventDefault();
    const prev = document.querySelector(`.host-wordle-cell-input[data-col="${col - 1}"]`);
    if (prev instanceof HTMLInputElement) prev.focus();
    return;
  }
}

document.addEventListener('keydown', event => {
  handleHostWordleCellNavigation(event);
  handleWordChainArrowNavigation(event);
  if (event.key === 'Enter' && APP.room?.currentActivity === 'emoji-charades') {
    const active = document.activeElement;
    if (active && active.id === 'emojiCharadesGuessInput') {
      event.preventDefault();
      submitEmojiCharadesGuess();
    }
  }
});

document.addEventListener('input', event => {
  const target = event.target;
  if (!(target instanceof HTMLInputElement)) return;
  if (target.classList.contains('host-wordle-cell-input')) {
    target.value = normalizeWord(target.value).slice(0, 1);
    captureHostWordleDraft();
    const col = Number.parseInt(target.dataset.col || '', 10);
    if (target.value && Number.isInteger(col)) {
      const next = document.querySelector(`.host-wordle-cell-input[data-col="${col + 1}"]`);
      if (next instanceof HTMLInputElement) next.focus();
    }
    return;
  }
  if (!target.classList.contains('word-chain-letter-input')) return;
  target.value = normalizeChainWord(target.value).slice(0, 1);

  const row = Number.parseInt(target.dataset.row || '', 10);
  const pos = Number.parseInt(target.dataset.pos || '', 10);
  if (!Number.isInteger(row) || !Number.isInteger(pos)) return;
  captureWordChainRowDraft(row);

  if (target.value) {
    const next = document.querySelector(`.word-chain-letter-input[data-row="${row}"][data-pos="${pos + 1}"]`);
    if (next instanceof HTMLInputElement) next.focus();
  }
});

document.addEventListener('dragstart', event => {
  const note = event.target instanceof HTMLElement ? event.target.closest('.brain-note') : null;
  if (!note) return;
  brainstormDraggedNoteId = note.dataset.noteId || null;
  if (event.dataTransfer) {
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', brainstormDraggedNoteId || '');
  }
});

document.addEventListener('dragover', event => {
  const lane = event.target instanceof HTMLElement ? event.target.closest('[data-brain-lane]') : null;
  if (!lane) return;
  event.preventDefault();
  if (event.dataTransfer) event.dataTransfer.dropEffect = 'move';
});

document.addEventListener('drop', async event => {
  const laneEl = event.target instanceof HTMLElement ? event.target.closest('[data-brain-lane]') : null;
  if (!laneEl) return;
  event.preventDefault();
  const laneId = laneEl.dataset.brainLane;
  const droppedNoteId = (event.dataTransfer?.getData('text/plain') || brainstormDraggedNoteId || '').trim();
  brainstormDraggedNoteId = null;
  if (!laneId || !droppedNoteId) return;
  await brainstormMoveNote(droppedNoteId, laneId);
});

document.addEventListener('click', async (event) => {
      case 'save-meeting': {
        // Collect meeting details
        const date = document.getElementById('meetingDate')?.value || '';
        const time = document.getElementById('meetingTime')?.value || '';
        const zoomLink = document.getElementById('zoomLink')?.value || '';
        const details = document.getElementById('meetingDetails')?.value || '';
        // Collect selected activities for the queue
        const activityCheckboxes = document.querySelectorAll('.activity-queue-checkbox');
        const activityQueue = Array.from(activityCheckboxes)
          .filter(cb => cb.checked)
          .map(cb => cb.value);
        // Build meeting object
        const meeting = {
          date,
          time,
          zoomLink,
          details,
          activityQueue,
          createdAt: new Date().toISOString()
        };
        // Save to localStorage (can be replaced with backend/API later)
        let meetings = [];
        try {
          meetings = JSON.parse(localStorage.getItem('scheduled-meetings') || '[]');
          if (!Array.isArray(meetings)) meetings = [];
        } catch (e) { meetings = []; }
        meetings.push(meeting);
        localStorage.setItem('scheduled-meetings', JSON.stringify(meetings));
        showError('Meeting saved!');
        goToScreen('dashboard');
        break;
      }
  const target = event.target.closest('[data-action]');
  if (!target) return;

  const { action, avatar, screen, key, index, feedbackId, activity, queueIndex, noteId, lane, direction, tab, word } = target.dataset;
  const parsedIndex = Number.parseInt(index ?? '', 10);
  const parsedQueueIndex = Number.parseInt(queueIndex ?? '', 10);

  switch (action) {
    case 'toggle-presentation':
      togglePresentation();
      break;
    case 'select-avatar':
      if (avatar) selectAvatar(avatar);
      break;
    case 'create-player':
      await createPlayer();
      break;
    case 'go-screen':
      if (screen) goToScreen(screen);
      break;
    case 'view-stats':
      viewStats();
      break;
    case 'open-feedback':
      await openFeedbackHub();
      break;
    case 'refresh-feedback':
      await refreshMyFeedback();
      break;
    case 'submit-feedback':
      await submitFeedback();
      break;
    case 'open-admin-console':
      openAdminConsole();
      break;
    case 'admin-login':
      await adminLogin();
      break;
    case 'admin-logout':
      adminLogout();
      break;
    case 'refresh-admin-feedback':
      await refreshAdminFeedback();
      break;
    case 'save-admin-feedback-item':
      if (feedbackId) await saveAdminFeedbackItem(feedbackId);
      break;
    case 'save-admin-config':
      await saveAdminConfig();
      break;
    case 'queue-add':
      if (activity) await queueAddActivity(activity);
      break;
    case 'queue-remove':
      if (Number.isInteger(parsedQueueIndex)) await queueRemoveActivityAt(parsedQueueIndex);
      break;
    case 'queue-clear':
      await queueClearAll();
      break;
    case 'queue-start':
      await queueStartRun();
      break;
    case 'queue-next':
      await queueNextActivity();
      break;
    case 'save-shared-presentation':
      await saveSharedPresentation();
      break;
    case 'clear-shared-presentation':
      await clearSharedPresentation();
      break;
    case 'open-shared-presentation':
      openSharedPresentation();
      break;
    case 'edit-profile':
      editProfile();
      break;
    case 'open-host-settings':
      openHostSettings();
      break;
    case 'close-host-settings':
      closeHostSettings();
      break;
    case 'host-settings-tab':
      switchHostSettingsTab(tab || 'game');
      break;
    case 'save-host-settings':
      await saveHostSettings();
      break;
    case 'cancel-edit-profile':
      cancelEditProfile();
      break;
    case 'select-edit-avatar':
      if (avatar) selectEditAvatar(avatar);
      break;
    case 'save-profile':
      await saveProfile();
      break;
    case 'join-room':
      await joinRoom();
      break;
    case 'copy-join-link':
      await copyJoinLink();
      break;
    case 'leave-session':
      await leaveSession();
      break;
    case 'start-lightning-trivia':
      await startLightningTrivia();
      break;
    case 'start-emoji-charades':
      await startEmojiCharades();
      break;
    case 'start-icebreaker':
      await startIcebreaker();
      break;
    case 'start-pulse-check':
      await startPulseCheck();
      break;
    case 'start-values-vote':
      await startValuesVote();
      break;
    case 'start-wordle':
      await startWordle();
      break;
    case 'start-word-chain':
      await startWordChain();
      break;
    case 'start-brainstorm-canvas':
      await startBrainstormCanvas();
      break;
    case 'start-regular-trivia':
      await startRegularTrivia();
      break;
    case 'generate-ai-questions':
      await generateAIQuestions();
      break;
    case 'end-activity':
      await endActivity();
      break;
    case 'submit-icebreaker-answer':
      await submitIcebreakerAnswer();
      break;
    case 'submit-emoji-charades-guess':
      await submitEmojiCharadesGuess();
      break;
    case 'reveal-emoji-charades':
      await revealEmojiCharades();
      break;
    case 'next-emoji-charades':
      await nextEmojiCharadesRound();
      break;
    case 'new-emoji-charades-round':
      await startEmojiCharades();
      break;
    case 'next-icebreaker-question':
      await nextIcebreakerQuestion();
      break;
    case 'submit-pulse-vote':
      if (Number.isInteger(parsedIndex)) await submitPulseVote(parsedIndex);
      break;
    case 'next-pulse-question':
      await nextPulseQuestion();
      break;
    case 'pulse-export-json':
      await exportPulseCheckData('json');
      break;
    case 'pulse-export-csv':
      await exportPulseCheckData('csv');
      break;
    case 'toggle-value-vote':
      if (Number.isInteger(parsedIndex)) await toggleValueVote(parsedIndex);
      break;
    case 'wordle-key':
      if (key) handleWordleKey(key);
      break;
    case 'submit-wordle-suggestion':
      await submitWordleSuggestion();
      break;
    case 'submit-wordle-vote':
      await submitWordleVote(word || '');
      break;
    case 'submit-wordle-guess':
      await submitWordleGuess();
      break;
    case 'new-wordle-round':
      await newWordleRound();
      break;
    case 'submit-word-chain-guess':
      await submitWordChainGuess();
      break;
    case 'submit-word-chain-suggestion':
      await submitWordChainSuggestion();
      break;
    case 'submit-word-chain-vote':
      await submitWordChainVote(word || '');
      break;
    case 'brainstorm-add-note':
      await brainstormAddNote();
      break;
    case 'brainstorm-toggle-vote':
      if (noteId) await brainstormToggleVote(noteId);
      break;
    case 'brainstorm-move-note':
      if (noteId && lane) await brainstormMoveNote(noteId, lane);
      break;
    case 'brainstorm-shift-note':
      if (noteId && direction) await brainstormShiftNote(noteId, direction);
      break;
    case 'brainstorm-toggle-lock':
      await brainstormToggleLock();
      break;
    case 'brainstorm-export-json':
      await exportBrainstormData('json');
      break;
    case 'brainstorm-export-csv':
      await exportBrainstormData('csv');
      break;
    case 'new-word-chain-puzzle':
      await startWordChain();
      break;
    case 'submit-regular-trivia-answer':
      if (Number.isInteger(parsedIndex)) await submitRegularTriviaAnswer(parsedIndex);
      break;
    case 'reveal-regular-answer':
      await revealRegularAnswer();
      break;
    case 'next-regular-trivia':
      await nextRegularTrivia();
      break;
    case 'submit-answer':
      if (Number.isInteger(parsedIndex)) await submitAnswer(parsedIndex);
      break;
    case 'send-lightning-reaction':
      if (target.dataset.emoji) await sendLightningReaction(target.dataset.emoji);
      break;
    case 'reveal-answer':
      await revealAnswer();
      break;
    case 'next-question':
      await nextQuestion();
      break;
    case 'play-again':
      await playAgain();
      break;
    default:
      break;
  }
});

function renderActivity() {
  const activity = APP.room.currentActivity;
  let content = '<div>Activity loading...</div>';

  if (activity === 'lightning-trivia') content = renderLightningTrivia();
  else if (activity === 'emoji-charades') content = renderEmojiCharades();
  else if (activity === 'icebreaker') content = renderIcebreaker();
  else if (activity === 'pulse-check') content = renderPulseCheck();
  else if (activity === 'values-vote') content = renderValuesVote();
  else if (activity === 'wordle') content = renderWordle();
  else if (activity === 'word-chain') content = renderWordChain();
  else if (activity === 'brainstorm-canvas') content = renderBrainstormCanvas();
  else if (activity === 'regular-trivia') content = renderRegularTrivia();

  return `
    <div style="display:flex;justify-content:flex-end;gap:10px;margin-bottom:8px;">
      <button class="btn-secondary" data-action="leave-session">ğŸšª Leave Session</button>
    </div>
    ${content}
  `;
}

async function submitIcebreakerAnswer() {
  const answer = (document.getElementById('icebreakerAnswer')?.value || '').trim().slice(0, 280);
  if (!answer) {
    showError('Please enter an answer');
    return;
  }
  
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room.activityState.answers) room.activityState.answers = {};
  
  room.activityState.answers[APP.player.name] = answer;
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function nextIcebreakerQuestion() {
  const room = await RoomManager.loadRoom(APP.roomCode);
  const randomQ = ICEBREAKER_QUESTIONS[Math.floor(Math.random() * ICEBREAKER_QUESTIONS.length)];
  room.activityState.currentQuestion = randomQ;
  room.activityState.answers = {};
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

function renderIcebreaker() {
  const state = APP.room.activityState || {};
  const question = state.currentQuestion;
  const answers = state.answers || {};
  const hasAnswered = answers[APP.player.name];
  const isHost = APP.room.host === APP.player.name;
  const safeRoomCode = escapeHtml(APP.roomCode);
  const safeQuestion = escapeHtml(question);
  
  return `
    <div class="header">
      <h1 style="font-size:2rem;font-weight:700;">ğŸ² Icebreaker Roulette</h1>
      <p class="tagline">Room: ${safeRoomCode}</p>
    </div>
    
    ${isHost ? '<button class="btn-secondary" data-action="end-activity">â† End Activity</button>' : ''}
    
    <div style="background:var(--surface-solid);border:2px solid var(--accent);
      border-radius:var(--radius);padding:40px 30px;margin:30px 0;text-align:center;">
      <div style="font-family:'Fraunces',serif;font-size:${APP.presentationMode ? '2.5rem' : '1.8rem'};
        font-weight:700;line-height:1.4;">
        ${safeQuestion}
      </div>
    </div>
    
    ${!hasAnswered ? `
      <div style="max-width:600px;margin:0 auto 20px;">
        <textarea id="icebreakerAnswer" 
          style="width:100%;background:var(--surface-2);border:1px solid var(--border);
          color:var(--text);padding:16px;border-radius:10px;font-size:1rem;
          font-family:'Outfit',sans-serif;outline:none;resize:vertical;min-height:100px;"
          aria-label="Icebreaker response"
          placeholder="Type your answer..."></textarea>
        <button class="btn-primary" data-action="submit-icebreaker-answer" style="margin-top:12px;">
          Submit Answer
        </button>
      </div>
    ` : `
      <div role="status" aria-live="polite" aria-atomic="true" style="text-align:center;padding:16px;background:rgba(0,210,106,0.05);
        border:1px solid var(--success);border-radius:10px;color:var(--success);margin-bottom:20px;">
        âœ“ Answer submitted! Waiting for others...
      </div>
    `}
    
    <div style="background:var(--surface-solid);border:1px solid var(--border);
      border-radius:var(--radius);padding:24px;">
      <h3 aria-live="polite" aria-atomic="true" style="font-weight:600;margin-bottom:16px;">
        Responses (${Object.keys(answers).length}/${APP.room.participants.length})
      </h3>
      ${Object.entries(answers).map(([name, ans]) => `
        <div style="background:var(--surface-2);border-radius:10px;padding:16px;margin-bottom:12px;">
          <div style="color:var(--accent);font-weight:600;margin-bottom:8px;font-size:0.9rem;">${escapeHtml(name)}</div>
          <div style="color:var(--text-mid);line-height:1.5;">${escapeHtml(ans)}</div>
        </div>
      `).join('') || '<p role="status" aria-live="polite" style="text-align:center;color:var(--text-dim);">No responses yet...</p>'}
    </div>
    
    ${isHost ? '<button class="btn-primary" data-action="next-icebreaker-question" style="margin-top:20px;">Next Question</button>' : ''}
  `;
}

async function submitPulseVote(optionIndex) {
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room) {
    showError('Room no longer available.');
    return;
  }
  if (room.activityState?.showResults) return;
  const currentPollIndex = room.activityState?.currentPoll || 0;
  const selected = room.activityState?.selectedPollIndexes || [];
  const questionIndex = selected[currentPollIndex] ?? currentPollIndex;
  const currentPoll = PULSE_QUESTIONS[questionIndex];
  if (!currentPoll) return;
  if (!room.activityState.votes) room.activityState.votes = {};
  
  room.activityState.votes[APP.player.name] = optionIndex;
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function nextPulseQuestion() {
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room) {
    showError('Room no longer available.');
    return;
  }
  const selected = room.activityState?.selectedPollIndexes || [];
  const totalPolls = selected.length || PULSE_QUESTIONS.length;
  if (!room.activityState.voteHistory) room.activityState.voteHistory = {};
  const currentPoll = room.activityState.currentPoll || 0;
  room.activityState.voteHistory[currentPoll] = { ...(room.activityState.votes || {}) };

  if (currentPoll >= totalPolls - 1) {
    room.activityState.showResults = true;
  } else {
    room.activityState.currentPoll = currentPoll + 1;
    room.activityState.votes = {};
  }
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

function renderPulseCheck() {
  const state = APP.room.activityState || {};
  const selected = state.selectedPollIndexes || [];
  const totalPolls = selected.length || PULSE_QUESTIONS.length;
  const questionIndex = selected[state.currentPoll || 0] ?? (state.currentPoll || 0);
  const poll = PULSE_QUESTIONS[questionIndex];
  const votes = state.votes || {};
  const userVote = votes[APP.player.name];
  const isHost = APP.room.host === APP.player.name;
  
  const voteCounts = {};
  Object.values(votes).forEach(v => voteCounts[v] = (voteCounts[v] || 0) + 1);
  const safeRoomCode = escapeHtml(APP.roomCode);
  const showResults = Boolean(state.showResults);

  if (showResults) {
    return renderPulseResults(state, isHost, safeRoomCode);
  }

  if (!poll) {
    return `
      <div class="header">
        <h1 style="font-size:2rem;font-weight:700;">ğŸ“Š Team Pulse Check</h1>
        <p class="tagline">Room: ${safeRoomCode}</p>
      </div>
      <div role="status" aria-live="polite" aria-atomic="true"
        style="text-align:center;padding:24px;background:var(--surface-solid);border:1px solid var(--border);border-radius:12px;">
        Pulse check is complete.
      </div>
      ${isHost ? '<button class="btn-primary" data-action="end-activity" style="margin-top:20px;">Back to Lobby</button>' : ''}
    `;
  }
  
  return `
    <div class="header">
      <h1 style="font-size:2rem;font-weight:700;">ğŸ“Š Team Pulse Check</h1>
      <p class="tagline">Poll ${(state.currentPoll || 0) + 1} of ${totalPolls} â€¢ Room: ${safeRoomCode}</p>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;">
      ${isHost ? '<button class="btn-secondary" data-action="end-activity">â† End Activity</button>' : '<span></span>'}
      <div style="display:flex;gap:8px;flex-wrap:wrap;">
        <button class="btn-secondary" data-action="pulse-export-json">Export JSON</button>
        <button class="btn-secondary" data-action="pulse-export-csv">Export CSV</button>
      </div>
    </div>
    
    <div style="background:var(--surface-solid);border:2px solid var(--accent);
      border-radius:var(--radius);padding:40px 30px;margin:30px 0;text-align:center;">
      <div style="font-family:'Fraunces',serif;font-size:${APP.presentationMode ? '2.5rem' : '1.8rem'};
        font-weight:700;">
        ${poll.q}
      </div>
    </div>
    
    <div style="max-width:700px;margin:0 auto;">
      ${poll.opts.map((opt, i) => {
        const isSelected = userVote === i;
        const voteCount = voteCounts[i] || 0;
        const totalVotes = Object.keys(votes).length;
        const percentage = totalVotes > 0 ? Math.round((voteCount / totalVotes) * 100) : 0;
        
        return `
          <button type="button" class="tile-btn" data-action="submit-pulse-vote" data-index="${i}" aria-pressed="${isSelected ? 'true' : 'false'}"
            style="display:flex;justify-content:space-between;align-items:center;
            background:var(--surface-2);border:2px solid ${isSelected ? 'var(--accent)' : 'var(--border)'};
            border-radius:12px;padding:20px 24px;margin-bottom:12px;cursor:pointer;
            transition:all 0.3s;position:relative;overflow:hidden;
            ${isSelected ? 'background:rgba(0,210,211,0.06);' : ''}">
            
            ${totalVotes > 0 ? `
              <div style="position:absolute;left:0;top:0;bottom:0;
                background:rgba(0,210,211,0.1);width:${percentage}%;
                transition:width 0.5s ease-out;"></div>
            ` : ''}
            
            <span style="position:relative;z-index:1;font-size:1.1rem;font-weight:600;">${opt}</span>
            ${totalVotes > 0 ? `
              <div style="position:relative;z-index:1;display:flex;align-items:center;gap:10px;">
                <span style="color:var(--text-dim);font-size:0.9rem;">${percentage}%</span>
                <span style="background:var(--accent);color:var(--bg);padding:6px 14px;
                  border-radius:20px;font-size:0.85rem;font-weight:700;">${voteCount}</span>
              </div>
            ` : ''}
          </button>
        `;
      }).join('')}
    </div>
    
    <div role="status" aria-live="polite" aria-atomic="true" style="text-align:center;padding:16px;color:var(--text-dim);margin-top:20px;">
      ${Object.keys(votes).length} of ${APP.room.participants.length} voted
    </div>
    
    ${isHost ? `<button class="btn-primary" data-action="next-pulse-question" style="margin-top:20px;">${(state.currentPoll || 0) >= totalPolls - 1 ? 'View Results' : 'Next Poll'}</button>` : ''}
  `;
}

function renderPulseResults(state, isHost, safeRoomCode) {
  const voteHistory = state.voteHistory || {};
  const selected = state.selectedPollIndexes || [];
  const resultIndexes = selected.length ? selected : PULSE_QUESTIONS.map((_, i) => i);
  let resultsHtml = '';

  resultIndexes.forEach((sourceIndex, pollIndex) => {
    const poll = PULSE_QUESTIONS[sourceIndex];
    if (!poll) return;
    const pollVotes = voteHistory[pollIndex] || {};
    const totalVotes = Object.keys(pollVotes).length;
    const counts = {};
    Object.values(pollVotes).forEach(v => {
      counts[v] = (counts[v] || 0) + 1;
    });

    resultsHtml += `
      <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:12px;padding:20px;margin-bottom:14px;">
        <div style="font-weight:700;margin-bottom:10px;color:var(--text);">${pollIndex + 1}. ${escapeHtml(poll.q)}</div>
        ${poll.opts.map((opt, optIndex) => {
          const count = counts[optIndex] || 0;
          const pct = totalVotes > 0 ? Math.round((count / totalVotes) * 100) : 0;
          return `
            <div style="margin-bottom:10px;">
              <div style="display:flex;justify-content:space-between;font-size:0.9rem;margin-bottom:4px;">
                <span>${escapeHtml(opt)}</span>
                <span style="color:var(--text-dim);">${count} vote${count === 1 ? '' : 's'} (${pct}%)</span>
              </div>
              <div style="height:8px;background:var(--surface-2);border-radius:999px;overflow:hidden;">
                <div style="height:100%;width:${pct}%;background:linear-gradient(90deg,var(--accent),var(--accent-2));"></div>
              </div>
            </div>
          `;
        }).join('')}
      </div>
    `;
  });

  return `
    <div class="header">
      <h1 style="font-size:2rem;font-weight:700;">ğŸ“Š Pulse Check Results</h1>
      <p class="tagline">Room: ${safeRoomCode}</p>
    </div>

    <div style="display:flex;justify-content:flex-end;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:10px;">
      <button class="btn-secondary" data-action="pulse-export-json">Export JSON</button>
      <button class="btn-secondary" data-action="pulse-export-csv">Export CSV</button>
    </div>

    <div role="status" aria-live="polite" aria-atomic="true"
      style="text-align:center;padding:14px;background:rgba(0,210,211,0.06);border:1px solid var(--accent);border-radius:10px;margin-bottom:20px;">
      Combined results from all pulse questions
    </div>

    ${resultsHtml}

    ${isHost
      ? '<button class="btn-primary" data-action="end-activity" style="margin-top:10px;">Back to Lobby</button>'
      : '<div style="text-align:center;color:var(--text-dim);margin-top:10px;">Waiting for host to close results...</div>'}
  `;
}

async function toggleValueVote(valueIndex) {
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room.activityState.votes) room.activityState.votes = {};
  
  if (!room.activityState.votes[APP.player.name]) room.activityState.votes[APP.player.name] = [];
  
  const userVotes = room.activityState.votes[APP.player.name];
  if (userVotes.includes(valueIndex)) {
    userVotes.splice(userVotes.indexOf(valueIndex), 1);
  } else if (userVotes.length < 5) {
    userVotes.push(valueIndex);
  }
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

function renderValuesVote() {
  const state = APP.room.activityState || {};
  const votes = state.votes || {};
  const userVotes = votes[APP.player.name] || [];
  const isHost = APP.room.host === APP.player.name;
  
  const allVotes = {};
  Object.values(votes).forEach(list => {
    if (Array.isArray(list)) {
      list.forEach(v => allVotes[v] = (allVotes[v] || 0) + 1);
    }
  });
  const safeRoomCode = escapeHtml(APP.roomCode);
  
  return `
    <div class="header">
      <h1 style="font-size:2rem;font-weight:700;">â­ Values Vote</h1>
      <p class="tagline">Room: ${safeRoomCode}</p>
    </div>
    
    ${isHost ? '<button class="btn-secondary" data-action="end-activity">â† End Activity</button>' : ''}
    
    <div style="text-align:center;padding:20px;background:rgba(0,210,211,0.05);
      border:1px solid var(--accent);border-radius:12px;margin:30px 0;">
      <strong style="font-size:1.1rem;">Select your top 3-5 team values</strong>
      <div role="status" aria-live="polite" aria-atomic="true" style="color:var(--text-dim);margin-top:8px;font-size:0.95rem;">
        ${userVotes.length} selected ${userVotes.length >= 3 && userVotes.length <= 5 ? 'âœ“' : ''}
      </div>
    </div>
    
    <div style="display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:16px;">
      ${TEAM_VALUES.map((val, i) => {
        const isSelected = userVotes.includes(i);
        const voteCount = allVotes[i] || 0;
        const borderColor = isSelected ? 'var(--accent)' : 'var(--border)';
        const bgColor = isSelected ? 'rgba(0,210,211,0.08)' : 'var(--surface)';
        
        return `
          <button type="button" class="tile-btn" data-action="toggle-value-vote" data-index="${i}" aria-pressed="${isSelected ? 'true' : 'false'}"
            style="background:${bgColor};border:2px solid ${borderColor};
            border-radius:12px;padding:${APP.presentationMode ? '32px' : '24px'};text-align:center;
            cursor:pointer;transition:all 0.3s;position:relative;">
            
            ${isSelected ? `
              <div style="position:absolute;top:8px;right:8px;width:24px;height:24px;
                background:var(--accent);border-radius:50%;display:grid;place-items:center;
                font-size:0.7rem;color:var(--bg);font-weight:700;">âœ“</div>
            ` : ''}
            
            <div style="font-size:${APP.presentationMode ? '4rem' : '3rem'};margin-bottom:10px;">${val.icon}</div>
            <div style="font-weight:700;margin-bottom:8px;font-size:${APP.presentationMode ? '1.2rem' : '1rem'};">
              ${val.name}
            </div>
            ${voteCount > 0 ? `
              <div style="margin-top:10px;">
                <span style="background:var(--accent);color:var(--bg);padding:6px 12px;
                  border-radius:12px;font-size:0.8rem;font-weight:700;">
                  ${voteCount} ${voteCount === 1 ? 'vote' : 'votes'}
                </span>
              </div>
            ` : ''}
          </button>
        `;
      }).join('')}
    </div>
    
    <div role="status" aria-live="polite" aria-atomic="true" style="text-align:center;padding:20px;margin-top:30px;background:var(--surface-2);
      border-radius:10px;border:1px solid var(--border);">
      <strong>${Object.keys(votes).length} of ${APP.room.participants.length} voted</strong>
      ${userVotes.length < 3 ? `
        <div style="color:var(--text-dim);font-size:0.85rem;margin-top:8px;">
          Select at least 3 values
        </div>
      ` : ''}
    </div>
  `;
}

async function submitWordleSuggestion() {
  const input = normalizeWord(document.getElementById('wordleInput')?.value || '');
  if (!input || input.length !== 5) {
    showError('Please enter a 5-letter word');
    return;
  }
  
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room.activityState.answers) room.activityState.answers = {};
  if (!room.activityState.wordleVotes) room.activityState.wordleVotes = {};
  
  room.activityState.answers[APP.player.name] = input;
  // Reset this player's vote whenever they update suggestion.
  delete room.activityState.wordleVotes[APP.player.name];
  const round = room.activityState.guesses?.length || 0;
  await awardParticipationInput(room, `wordle_suggest:${round}:${APP.player.name}`, 3);
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function submitWordleVote(word) {
  const normalized = normalizeWord(word || '');
  if (!normalized || normalized.length !== 5) {
    showError('Select a valid suggested word.');
    return;
  }

  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'wordle') return;
  if (room.activityState?.gameOver) return;

  const answers = room.activityState.answers || {};
  const suggestedWords = new Set(Object.values(answers).map(w => normalizeWord(w)));
  if (!suggestedWords.has(normalized)) {
    showError('That suggestion is no longer available.');
    return;
  }

  if (!room.activityState.wordleVotes) room.activityState.wordleVotes = {};
  room.activityState.wordleVotes[APP.player.name] = normalized;
  const round = room.activityState.guesses?.length || 0;
  await awardParticipationInput(room, `wordle_vote:${round}:${APP.player.name}`, 2);

  await RoomManager.updateRoom(APP.roomCode, room);
}

async function submitWordleGuess() {
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'wordle') return;
  const answers = room.activityState.answers || {};
  const wordleVotes = room.activityState.wordleVotes || {};
  const isHost = room.host === APP.player?.name;
  const hostTypedWord = isHost ? normalizeWord(hostWordleDraft || getHostTypedWordFromCells()) : '';
  
  if (hostTypedWord.length === 5) {
    room.activityState.guesses.push(hostTypedWord);
    if (hostTypedWord === room.activityState.targetWord) {
      room.activityState.gameOver = true;
    } else if (room.activityState.guesses.length >= 6) {
      room.activityState.gameOver = true;
    }
    room.activityState.answers = {};
    room.activityState.wordleVotes = {};
    hostWordleDraft = '';
    await RoomManager.updateRoom(APP.roomCode, room);
    return;
  }

  if (Object.keys(answers).length === 0) return;
  const validSuggestions = Array.from(new Set(Object.values(answers).map(w => normalizeWord(w)).filter(Boolean)));
  if (validSuggestions.length === 1) {
    const onlyWord = validSuggestions[0];
    room.activityState.guesses.push(onlyWord);
    if (onlyWord === room.activityState.targetWord) {
      room.activityState.gameOver = true;
    } else if (room.activityState.guesses.length >= 6) {
      room.activityState.gameOver = true;
    }
    room.activityState.answers = {};
    room.activityState.wordleVotes = {};
    hostWordleDraft = '';
    await RoomManager.updateRoom(APP.roomCode, room);
    return;
  }

  if (Object.keys(wordleVotes).length === 0) {
    showError('Need at least one vote before submitting.');
    return;
  }
  
  const validSuggestionSet = new Set(validSuggestions);
  const voteCounts = {};
  Object.values(wordleVotes).forEach(word => {
    if (!validSuggestionSet.has(word)) return;
    voteCounts[word] = (voteCounts[word] || 0) + 1;
  });
  
  const mostPopular = Object.entries(voteCounts).sort((a, b) => b[1] - a[1])[0]?.[0];
  if (!mostPopular) {
    showError('No valid voted suggestion found. Ask team to vote again.');
    return;
  }
  
  room.activityState.guesses.push(mostPopular);
  
  if (mostPopular === room.activityState.targetWord) {
    room.activityState.gameOver = true;
  } else if (room.activityState.guesses.length >= 6) {
    room.activityState.gameOver = true;
  }
  
  room.activityState.answers = {};
  room.activityState.wordleVotes = {};
  hostWordleDraft = '';
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function newWordleRound() {
  const word = WORDLE_WORDS[Math.floor(Math.random() * WORDLE_WORDS.length)];
  const room = await RoomManager.loadRoom(APP.roomCode);
  room.activityState = {
    targetWord: word,
    guesses: [],
    currentRow: 0,
    gameOver: false,
    answers: {},
    wordleVotes: {}
  };
  hostWordleDraft = '';
  
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function submitWordChainSuggestion() {
  const input = normalizeChainWord(document.getElementById('wordChainSuggestionInput')?.value || '');
  if (!input) {
    showError('Enter a word suggestion first.');
    return;
  }
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'word-chain') return;
  const state = room.activityState || {};
  if (!state.chainSuggestions) state.chainSuggestions = {};
  if (!state.chainVotes) state.chainVotes = {};
  state.chainSuggestions[APP.player.name] = input.slice(0, 9);
  delete state.chainVotes[APP.player.name];
  const row = state.progressIndex?.[TEAM_CHAIN_KEY] || 1;
  await awardParticipationInput(room, `wordchain_suggest:${row}:${APP.player.name}`, 3);
  room.activityState = state;
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function submitWordChainVote(word) {
  const normalized = normalizeChainWord(word || '').slice(0, 9);
  if (!normalized) {
    showError('Select a valid suggestion.');
    return;
  }
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'word-chain') return;
  const state = room.activityState || {};
  const suggestions = state.chainSuggestions || {};
  const suggestionSet = new Set(Object.values(suggestions).map(value => normalizeChainWord(value).slice(0, 9)));
  if (!suggestionSet.has(normalized)) {
    showError('That suggestion is no longer available.');
    return;
  }
  if (!state.chainVotes) state.chainVotes = {};
  state.chainVotes[APP.player.name] = normalized;
  const row = state.progressIndex?.[TEAM_CHAIN_KEY] || 1;
  await awardParticipationInput(room, `wordchain_vote:${row}:${APP.player.name}`, 2);
  room.activityState = state;
  await RoomManager.updateRoom(APP.roomCode, room);
}

function renderWordle() {
  const state = APP.room.activityState || {};
  const targetWord = state.targetWord || 'AGILE';
  const guesses = state.guesses || [];
  const gameOver = state.gameOver || false;
  const answers = state.answers || {};
  const wordleVotes = state.wordleVotes || {};
  const userGuess = answers[APP.player.name] || '';
  const userVote = wordleVotes[APP.player.name] || '';
  const isHost = APP.room.host === APP.player.name;
  const maxGuesses = 6;
  const safeRoomCode = escapeHtml(APP.roomCode);
  const safeUserGuess = escapeHtml(userGuess);
  const suggestionWords = Array.from(new Set(Object.values(answers).map(word => normalizeWord(word)).filter(Boolean)));
  const voteCounts = {};
  Object.values(wordleVotes).forEach(word => {
    const normalized = normalizeWord(word);
    if (!normalized || !suggestionWords.includes(normalized)) return;
    voteCounts[normalized] = (voteCounts[normalized] || 0) + 1;
  });
  const topVoteEntry = Object.entries(voteCounts).sort((a, b) => b[1] - a[1])[0] || null;
  const topVoteWord = topVoteEntry?.[0] || '';
  
  const letterStates = {};
  guesses.forEach(guess => {
    for (let i = 0; i < 5; i++) {
      const letter = guess[i];
      if (targetWord[i] === letter) letterStates[letter] = 'correct';
      else if (targetWord.includes(letter) && letterStates[letter] !== 'correct') letterStates[letter] = 'present';
      else if (!targetWord.includes(letter)) letterStates[letter] = 'absent';
    }
  });
  
  const won = guesses.includes(targetWord);
  const lost = !won && guesses.length >= maxGuesses;
  
  let gridHtml = '';
  const hostTypedWord = isHost ? normalizeWord(hostWordleDraft) : '';
  for (let row = 0; row < maxGuesses; row++) {
    gridHtml += '<div class="wordle-row">';
    const guess = guesses[row] || '';
    const isActiveHostRow = isHost && !gameOver && row === guesses.length;
    for (let col = 0; col < 5; col++) {
      const letter = guess[col] || '';
      let cellClass = 'wordle-cell';
      if (guess.length === 5) {
        if (targetWord[col] === letter) cellClass += ' correct';
        else if (targetWord.includes(letter)) cellClass += ' present';
        else cellClass += ' absent';
      }
      if (isActiveHostRow) {
        const typedLetter = hostTypedWord[col] || '';
        gridHtml += `<div class="${cellClass}"><input class="host-wordle-cell-input" data-col="${col}" maxlength="1" value="${escapeHtml(typedLetter)}" aria-label="Host letter ${col + 1}"></div>`;
      } else {
        gridHtml += '<div class="' + cellClass + '">' + letter + '</div>';
      }
    }
    gridHtml += '</div>';
  }
  
  const keyboard = [
    ['Q','W','E','R','T','Y','U','I','O','P'],
    ['A','S','D','F','G','H','J','K','L'],
    ['Z','X','C','V','B','N','M']
  ];
  
  let keyboardHtml = '<div style="max-width:500px;margin:20px auto;">';
  keyboard.forEach(row => {
    keyboardHtml += '<div style="display:flex;gap:6px;justify-content:center;margin-bottom:6px;">';
    row.forEach(key => {
      const state = letterStates[key] || '';
      const disabled = gameOver ? 'disabled' : '';
      keyboardHtml += '<button class="key-btn ' + state + '" data-action="wordle-key" data-key="' + key + '" ' + disabled + '>' + key + '</button>';
    });
    keyboardHtml += '</div>';
  });
  const disabled = gameOver ? 'disabled' : '';
  keyboardHtml += '<div style="display:flex;gap:6px;justify-content:center;">';
  keyboardHtml += '<button class="key-btn wide" data-action="wordle-key" data-key="ENTER" ' + disabled + '>ENTER</button>';
  keyboardHtml += '<button class="key-btn wide" data-action="wordle-key" data-key="DEL" ' + disabled + '>DEL</button>';
  keyboardHtml += '</div></div>';
  
  let statusHtml = '';
  if (won) {
    statusHtml = '<div role="status" aria-live="polite" aria-atomic="true" style="text-align:center;padding:20px;background:rgba(0,210,106,0.05);border:1px solid var(--success);border-radius:12px;color:var(--success);margin:20px 0;font-size:1.2rem;font-weight:700;">ğŸ‰ Team solved it in ' + guesses.length + ' ' + (guesses.length === 1 ? 'guess' : 'guesses') + '!</div>';
  } else if (lost) {
    statusHtml = '<div role="alert" aria-live="assertive" aria-atomic="true" style="text-align:center;padding:20px;background:rgba(255,64,96,0.05);border:1px solid var(--danger);border-radius:12px;margin:20px 0;">The word was: <strong style="color:var(--accent);font-size:1.5rem;display:block;margin-top:10px;">' + escapeHtml(targetWord) + '</strong></div>';
  }
  
  let suggestionsHtml = '';
  Object.entries(answers).forEach(([name, word]) => {
    const normalized = normalizeWord(word);
    const participant = APP.room.participants.find(p => p.name === name);
    const avatar = participant ? participant.avatar : 'ğŸ‘¤';
    suggestionsHtml += '<div style="background:var(--surface-2);border-radius:10px;padding:16px;margin-bottom:12px;display:flex;align-items:center;gap:12px;">';
    suggestionsHtml += '<div style="font-size:1.5rem;">' + escapeHtml(avatar) + '</div>';
    suggestionsHtml += '<div style="flex:1;"><div style="color:var(--accent);font-weight:600;margin-bottom:4px;">' + escapeHtml(name) + '</div>';
    suggestionsHtml += '<div style="font-size:1.2rem;font-weight:700;letter-spacing:4px;">' + escapeHtml(word) + '</div></div>';
    if (normalized && voteCounts[normalized]) {
      suggestionsHtml += '<span style="background:var(--accent);color:var(--bg);padding:6px 10px;border-radius:999px;font-size:0.78rem;font-weight:700;">' + voteCounts[normalized] + ' vote' + (voteCounts[normalized] === 1 ? '' : 's') + '</span>';
    }
    suggestionsHtml += '</div>';
  });
  
  const voteButtonsHtml = suggestionWords.map(word => {
    const isSelected = userVote === word;
    const count = voteCounts[word] || 0;
    const selectedStyle = isSelected
      ? 'background:rgba(0,210,211,0.08);border-color:var(--accent);'
      : 'background:var(--surface-2);border-color:var(--border);';
    return `
      <button type="button" class="tile-btn" data-action="submit-wordle-vote" data-word="${word}" aria-pressed="${isSelected ? 'true' : 'false'}"
        style="${selectedStyle}border:2px solid;border-radius:12px;padding:12px 14px;display:flex;justify-content:space-between;align-items:center;cursor:pointer;transition:all 0.2s;">
        <span style="font-weight:700;letter-spacing:3px;">${word}</span>
        <span style="font-size:0.82rem;color:var(--text-dim);">${count} vote${count === 1 ? '' : 's'}</span>
      </button>
    `;
  }).join('');
  
  return `
    <div class="header">
      <h1 style="font-size:2rem;font-weight:700;">ğŸ¯ Team Wordle</h1>
      <p class="tagline">Guess ${guesses.length + 1} of ${maxGuesses} â€¢ Room: ${safeRoomCode}</p>
    </div>
    
    ${isHost ? '<button class="btn-secondary" data-action="end-activity">â† End Activity</button>' : ''}
    
    ${userGuess ? `
      <div role="status" aria-live="polite" aria-atomic="true" style="text-align:center;padding:12px;background:rgba(0,210,211,0.05);
        border:1px solid var(--accent);border-radius:10px;margin-bottom:20px;">
        Your suggestion: <strong style="font-size:1.2rem;letter-spacing:2px;">${safeUserGuess}</strong>
      </div>
    ` : ''}
    
    <div class="wordle-grid">${gridHtml}</div>
    
    ${!gameOver ? keyboardHtml : ''}
    
    ${statusHtml}
    
    ${!gameOver ? `
      <div style="max-width:400px;margin:20px auto;">
        <div style="margin-bottom:12px;">
          <label for="wordleInput" style="display:block;text-align:center;margin-bottom:8px;font-weight:600;">
            Suggest a 5-letter word
          </label>
          <input type="text" id="wordleInput" 
            style="width:100%;background:var(--surface-2);border:1px solid var(--border);
            color:var(--text);padding:12px 16px;border-radius:10px;font-size:1.5rem;
            text-align:center;text-transform:uppercase;letter-spacing:8px;outline:none;"
            maxlength="5" placeholder="WORD"
            onfocus="this.style.borderColor='var(--accent)'"
            onblur="this.style.borderColor='var(--border)'">
        </div>
        <button class="btn-primary" data-action="submit-wordle-suggestion">
          ${userGuess ? 'Update Suggestion' : 'Submit Suggestion'}
        </button>
      </div>
      
      <div style="background:var(--surface-solid);border:1px solid var(--border);
        border-radius:var(--radius);padding:24px;margin-top:16px;">
        <h3 aria-live="polite" aria-atomic="true" style="font-weight:600;margin-bottom:12px;text-align:center;">
          Team Suggestions & Voting (${Object.keys(answers).length}/${APP.room.participants.length})
        </h3>
        ${suggestionWords.length ? `
          <div style="margin-bottom:12px;">
            ${suggestionsHtml}
          </div>
          <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;">
            ${voteButtonsHtml}
          </div>
          <div role="status" aria-live="polite" aria-atomic="true" style="text-align:center;color:var(--text-dim);margin-top:12px;">
            ${Object.keys(wordleVotes).length} of ${APP.room.participants.length} voted
            ${userVote ? ` â€¢ Your vote: <strong style="color:var(--accent);letter-spacing:2px;">${escapeHtml(userVote)}</strong>` : ''}
          </div>
          ${topVoteWord ? `
            <div style="text-align:center;margin-top:8px;color:var(--text-mid);font-size:0.9rem;">
              Current leader: <strong style="color:var(--accent);letter-spacing:2px;">${escapeHtml(topVoteWord)}</strong>
            </div>
          ` : ''}
        ` : '<p style="text-align:center;color:var(--text-dim);padding:8px;">Need at least one suggestion before voting.</p>'}
      </div>
      
      ${isHost && (Object.keys(answers).length > 0 || hostTypedWord.length === 5) ? `
        <button class="btn-primary" data-action="submit-wordle-guess" style="margin-top:20px;">
          ${hostTypedWord.length === 5 ? 'Submit Typed Word to Grid' : 'Submit Voted Word to Grid'}
        </button>
      ` : ''}
    ` : `
      ${isHost ? '<button class="btn-primary" data-action="new-wordle-round">New Round</button>' : ''}
    `}
  `;
}

async function submitWordChainGuess() {
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'word-chain') return;
  if (room.host !== APP.player?.name) {
    showError('Only host can submit the team row.');
    return;
  }

  const state = room.activityState || {};
  const puzzle = WORD_CHAIN_PUZZLES[state.puzzleIndex];
  if (!puzzle) return;

  if (!state.progressIndex) state.progressIndex = {};
  if (!state.revealedLetters) state.revealedLetters = {};
  if (!state.lastLetterGraceUsed) state.lastLetterGraceUsed = {};
  if (!state.solvedWords) state.solvedWords = {};
  if (!state.wordScores) state.wordScores = {};
  if (!state.wordAttempts) state.wordAttempts = {};
  if (!state.totalAttempts) state.totalAttempts = {};
  if (!state.completedAt) state.completedAt = {};
  if (!state.scores) state.scores = {};
  if (!state.feedback) state.feedback = {};
  if (!state.chainSuggestions) state.chainSuggestions = {};
  if (!state.chainVotes) state.chainVotes = {};

  const chain = (puzzle.words || []).slice(0, Math.min(8, state.wordCount || 8));
  if (chain.length < 3) return;

  const playerName = TEAM_CHAIN_KEY;
  const lastIndex = chain.length - 1;
  if (!state.progressIndex[playerName]) state.progressIndex[playerName] = 1;
  if (!state.revealedLetters[playerName]) state.revealedLetters[playerName] = { 1: 1 };
  if (!state.lastLetterGraceUsed[playerName]) state.lastLetterGraceUsed[playerName] = {};
  if (!state.solvedWords[playerName]) state.solvedWords[playerName] = {};
  if (!state.wordScores[playerName]) state.wordScores[playerName] = {};
  if (!state.wordAttempts[playerName]) state.wordAttempts[playerName] = {};

  const currentIndex = state.progressIndex[playerName];
  if (currentIndex >= lastIndex) return;

  const answer = normalizeChainWord(chain[currentIndex]);
  const revealCount = Math.max(1, Math.min(answer.length, state.revealedLetters[playerName]?.[currentIndex] || 1));
  const revealedPrefix = answer.slice(0, revealCount);
  captureWordChainRowDraft(currentIndex);
  const typedSuffix = normalizeChainWord(wordChainDraft[currentIndex] || '');
  const voteCounts = {};
  const validSuggestions = new Set(
    Object.values(state.chainSuggestions || {}).map(s => normalizeChainWord(s).slice(0, 9)).filter(Boolean)
  );
  Object.values(state.chainVotes || {}).forEach(v => {
    const val = normalizeChainWord(v).slice(0, 9);
    if (!validSuggestions.has(val)) return;
    voteCounts[val] = (voteCounts[val] || 0) + 1;
  });
  const votedWord = Object.entries(voteCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || '';
  let guess = '';
  if (typedSuffix) {
    guess = normalizeChainWord((revealedPrefix + typedSuffix).slice(0, answer.length));
  } else if (votedWord) {
    guess = normalizeChainWord(votedWord).slice(0, answer.length);
  }
  if (!guess) {
    showError('Need host typed input or at least one voted suggestion.');
    return;
  }

  state.totalAttempts[playerName] = (state.totalAttempts[playerName] || 0) + 1;
  const attemptForWord = (state.wordAttempts[playerName][currentIndex] || 0) + 1;
  state.wordAttempts[playerName][currentIndex] = attemptForWord;

  const solvedMap = state.solvedWords[playerName];
  const wordScoreMap = state.wordScores[playerName];
  const revealMap = state.revealedLetters[playerName];
  const graceMap = state.lastLetterGraceUsed[playerName];
  let newlySolved = false;
  let autoRevealedAdvance = false;
  let pointsEarned = 0;

  if (guess === answer) {
    solvedMap[currentIndex] = true;
    newlySolved = true;
    if (attemptForWord === 1) pointsEarned = 20;
    else if (attemptForWord === 2) pointsEarned = 15;
    else if (attemptForWord === 3) pointsEarned = 10;
    else pointsEarned = Math.max(0, 5 - (attemptForWord - 4)); // -1 for attempts after 4th
    state.scores[playerName] = (state.scores[playerName] || 0) + pointsEarned;
    wordScoreMap[currentIndex] = pointsEarned;

    state.progressIndex[playerName] = currentIndex + 1;
    delete graceMap[currentIndex];
    wordChainDraft[currentIndex] = '';
    const nextIndex = state.progressIndex[playerName];
    if (nextIndex < lastIndex) {
      revealMap[nextIndex] = Math.max(1, revealMap[nextIndex] || 1);
    } else {
      state.completedAt[playerName] = Date.now();
    }
  } else {
    const currentReveal = revealMap[currentIndex] || 1;
    const lastMissingLetter = currentReveal >= Math.max(1, answer.length - 1);
    if (lastMissingLetter && !graceMap[currentIndex]) {
      // Give one extra try when only one letter remains hidden.
      graceMap[currentIndex] = true;
    } else if (lastMissingLetter && graceMap[currentIndex]) {
      // Second miss on last-letter state: reveal it and advance.
      revealMap[currentIndex] = answer.length;
      solvedMap[currentIndex] = true;
      autoRevealedAdvance = true;
      pointsEarned = 0;
      wordScoreMap[currentIndex] = 0;
      delete graceMap[currentIndex];
      state.progressIndex[playerName] = currentIndex + 1;
      const nextIndex = state.progressIndex[playerName];
      if (nextIndex < lastIndex) {
        revealMap[nextIndex] = Math.max(1, revealMap[nextIndex] || 1);
      } else {
        state.completedAt[playerName] = Date.now();
      }
    } else {
      revealMap[currentIndex] = Math.min(answer.length, currentReveal + 1);
    }
    wordChainDraft[currentIndex] = '';
    const activeRowInputs = document.querySelectorAll(`.word-chain-letter-input[data-row="${currentIndex}"]`);
    activeRowInputs.forEach(input => {
      if (input instanceof HTMLInputElement) input.value = '';
    });
  }
  state.chainSuggestions = {};
  state.chainVotes = {};

  state.solvedWords[playerName] = solvedMap;
  state.wordScores[playerName] = wordScoreMap;
  state.revealedLetters[playerName] = revealMap;
  state.lastLetterGraceUsed[playerName] = graceMap;

  const solvedCount = Object.keys(solvedMap).length;
  const hiddenTotal = Math.max(0, lastIndex - 1);
  const remaining = Math.max(0, hiddenTotal - solvedCount);
  const now = Date.now();
  state.feedback[playerName] = {
    correctThisRound: newlySolved ? 1 : 0,
    remaining,
    attempts: state.totalAttempts[playerName] || 0,
    pointsEarned,
    autoRevealedAdvance,
    ts: now
  };

  // Force focus refresh after every submit (wrong: same row, correct: next row).
  resetWordChainFocusState();
  room.activityState = state;
  await RoomManager.updateRoom(APP.roomCode, room);
}

function renderWordChain() {
  const state = APP.room.activityState || {};
  const puzzle = WORD_CHAIN_PUZZLES[state.puzzleIndex];
  const isHost = APP.room.host === APP.player.name;
  const safeRoomCode = escapeHtml(APP.roomCode);

  if (!puzzle) {
    return `
      <div class="header">
        <h1 style="font-size:2rem;font-weight:700;">ğŸ”— Word Chain</h1>
        <p class="tagline">Room: ${safeRoomCode}</p>
      </div>
      <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:12px;padding:20px;">
        Puzzle unavailable.
      </div>
    `;
  }

  const playerName = TEAM_CHAIN_KEY;
  const chain = (puzzle.words || []).slice(0, Math.min(8, state.wordCount || 8));
  const lastIndex = chain.length - 1;
  const playerProgress = state.progressIndex?.[playerName] || 1;
  const revealMap = state.revealedLetters?.[playerName] || { 1: 1 };
  const solvedMap = state.solvedWords?.[playerName] || {};
  const wordScoreMap = state.wordScores?.[playerName] || {};
  const wordAttempts = state.wordAttempts?.[playerName] || {};
  const totalAttempts = state.totalAttempts?.[playerName] || 0;
  const feedback = state.feedback?.[playerName];
  const solvedCount = Object.keys(solvedMap).length;
  const hiddenTotal = Math.max(0, lastIndex - 1);
  const completedAt = state.completedAt?.[playerName];
  const score = state.scores?.[playerName] || 0;
  const elapsedSec = Math.max(0, Math.floor((Date.now() - (state.startedAt || Date.now())) / 1000));
  const suggestions = state.chainSuggestions || {};
  const votes = state.chainVotes || {};
  const userSuggestion = suggestions[APP.player.name] || '';
  const userVote = votes[APP.player.name] || '';
  const suggestionWords = Array.from(new Set(Object.values(suggestions).map(word => normalizeChainWord(word).slice(0, 9)).filter(Boolean)));
  const voteCounts = {};
  Object.values(votes).forEach(word => {
    const normalized = normalizeChainWord(word).slice(0, 9);
    if (!suggestionWords.includes(normalized)) return;
    voteCounts[normalized] = (voteCounts[normalized] || 0) + 1;
  });
  const topVoteEntry = Object.entries(voteCounts).sort((a, b) => b[1] - a[1])[0] || null;
  const topVoteWord = topVoteEntry?.[0] || '';

  const participation = APP.room.participants.map(p => ({
    name: p.name,
    avatar: p.avatar,
    suggestion: suggestions[p.name] || '',
    vote: votes[p.name] || ''
  }));

  let gridHtml = '<div class="word-chain-board">';
  chain.forEach((word, idx) => {
    const normalized = normalizeChainWord(word).slice(0, 9);
    const isFirst = idx === 0;
    const isLast = idx === lastIndex;
    const isSolved = Boolean(solvedMap[idx]);
    const isActiveRow = idx === playerProgress && !isSolved && !isFirst && !isLast;
    const rowAttempts = wordAttempts[idx] || 0;
    const rowScore = Number(wordScoreMap[idx] ?? 0);
    const missHue = Math.max(0, 120 - (rowAttempts * 24)); // 120 (green) -> 0 (red)
    const missBorder = `hsl(${missHue} 72% 45%)`;
    const missBg = `hsla(${missHue}, 72%, 45%, 0.2)`;
    const finalHue = Math.max(0, Math.min(120, Math.round((rowScore / 20) * 120)));
    const finalBorder = `hsl(${finalHue} 72% 45%)`;
    const finalBg = `hsla(${finalHue}, 72%, 45%, 0.25)`;
    const baseReveal = revealMap[idx] ?? (idx === playerProgress ? 1 : 0);
    const revealedChars = isFirst || isLast || isSolved
      ? normalized.length
      : Math.max(0, Math.min(normalized.length, baseReveal));

    gridHtml += `
      <div class="word-chain-board-row">
        <div class="word-chain-row">
            ${Array.from({ length: 9 }, (_, pos) => {
              const showChar = pos < revealedChars && pos < normalized.length;
              const char = showChar ? normalized[pos] || '' : '';
              const isBlank = pos >= normalized.length;
              const draftChar = (wordChainDraft[idx] || '')[Math.max(0, pos - revealedChars)] || '';
              const isMiddleSolved = isSolved && !isFirst && !isLast;
              const cellClass = isFirst
                ? 'word-chain-cell top-anchor'
                : isLast
                  ? 'word-chain-cell bottom-anchor'
                  : 'word-chain-cell';
              if (isActiveRow && pos >= revealedChars && isHost) {
                const firstEditableAttr = pos === revealedChars ? 'data-first-editable="true"' : '';
                const missStyle = rowAttempts > 0 ? `style="border-color:${missBorder};background:${missBg};"` : '';
                return `<input class="word-chain-letter-input" data-row="${idx}" data-pos="${pos}" ${firstEditableAttr} ${missStyle} value="${escapeHtml(draftChar)}" maxlength="1" aria-label="Row ${idx + 1} letter ${pos + 1} of 9">`;
              }
              if (isBlank && !isFirst && !isLast && !isMiddleSolved) {
                const missStyle = rowAttempts > 0 ? `style="border-color:${missBorder};background:${missBg};"` : '';
                return `<div class="${cellClass}" ${missStyle}></div>`;
              }
              const solvedStyle = isMiddleSolved ? `style="border-color:${finalBorder};background:${finalBg};"` : '';
              const missStyle = (!isFirst && !isLast && !isSolved && rowAttempts > 0) ? `style="border-color:${missBorder};background:${missBg};"` : '';
              return `<div class="${cellClass}" ${solvedStyle || missStyle}>${escapeHtml(char)}</div>`;
            }).join('')}
        </div>
        ${idx > 0 && idx < lastIndex && Object.prototype.hasOwnProperty.call(wordScoreMap, idx)
          ? `<span class="word-chain-score-bubble">+${Number(wordScoreMap[idx]) || 0}</span>`
          : '<span></span>'}
      </div>
    `;
  });
  gridHtml += '</div>';

  const allDone = hiddenTotal > 0 && solvedCount >= hiddenTotal;
  const statusLine = allDone
    ? `Solved ${hiddenTotal} words in ${totalAttempts} ${totalAttempts === 1 ? 'attempt' : 'attempts'} â€¢ Score ${score}`
    : `${solvedCount}/${hiddenTotal} words solved â€¢ Total attempts: ${totalAttempts}`;

  return `
    <div class="header">
      <h1 style="font-size:2rem;font-weight:700;">ğŸ”— Word Chain</h1>
      <p class="tagline">${escapeHtml(puzzle.title)} â€¢ Room: ${safeRoomCode}</p>
    </div>

    ${isHost ? '<button class="btn-secondary" data-action="end-activity">â† End Activity</button>' : ''}

    <div class="word-chain-shell">
      <div class="word-chain-help">
        Team mode: first and last words are revealed. Solve middle words together (up to 8 total words).
      </div>
      <div class="word-chain-help">
        Submit by voted suggestion or host typed row. On wrong attempts, one more letter is revealed.
      </div>
      ${gridHtml}

      <div class="word-chain-status" role="status" aria-live="polite" aria-atomic="true">
        ${statusLine}
      </div>

      ${feedback && !allDone ? `
        <div style="margin-top:8px;color:var(--text-mid);font-size:0.9rem;">
          Last submit: ${
            feedback.correctThisRound
              ? `correct word solved (+${feedback.pointsEarned || 0})`
              : feedback.autoRevealedAdvance
                ? 'final letter revealed, advanced to next word'
                : 'not matched'
          } â€¢ ${feedback.remaining} remaining.
        </div>
      ` : ''}

      ${!allDone ? `
        <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:12px;padding:16px;margin-top:12px;">
          <div style="font-weight:700;margin-bottom:10px;">Team Suggestions & Voting</div>
          <div style="display:grid;grid-template-columns:1fr auto;gap:8px;margin-bottom:10px;">
            <input id="wordChainSuggestionInput" class="form-input" maxlength="9" value="${escapeHtml(userSuggestion)}" placeholder="Suggest word (up to 9 letters)">
            <button class="btn-secondary" data-action="submit-word-chain-suggestion" style="width:auto;padding:10px 14px;">${userSuggestion ? 'Update' : 'Suggest'}</button>
          </div>
          ${suggestionWords.length ? `
            <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;">
              ${suggestionWords.map(word => {
                const isSelected = userVote === word;
                const count = voteCounts[word] || 0;
                return `
                  <button type="button" class="tile-btn" data-action="submit-word-chain-vote" data-word="${word}" aria-pressed="${isSelected ? 'true' : 'false'}"
                    style="border:2px solid ${isSelected ? 'var(--accent)' : 'var(--border)'};background:${isSelected ? 'rgba(0,210,211,0.08)' : 'var(--surface-2)'};
                    border-radius:10px;padding:10px 12px;display:flex;justify-content:space-between;align-items:center;cursor:pointer;">
                    <span style="font-weight:700;letter-spacing:2px;">${escapeHtml(word)}</span>
                    <span style="font-size:0.82rem;color:var(--text-dim);">${count} vote${count === 1 ? '' : 's'}</span>
                  </button>
                `;
              }).join('')}
            </div>
          ` : '<div style="color:var(--text-dim);font-size:0.9rem;">No suggestions yet.</div>'}
          <div style="margin-top:8px;color:var(--text-dim);font-size:0.85rem;">
            ${Object.keys(votes).length} of ${APP.room.participants.length} voted
            ${topVoteWord ? ` â€¢ Leader: <strong style="color:var(--accent);letter-spacing:2px;">${escapeHtml(topVoteWord)}</strong>` : ''}
          </div>
        </div>
      ` : ''}

      ${!allDone ? `
        <div style="margin-top:12px;display:flex;justify-content:flex-end;">
          ${isHost ? `
            <button class="btn-primary" data-action="submit-word-chain-guess" style="width:auto;padding:12px 22px;">
              Submit Team Row
            </button>
          ` : '<div style="color:var(--text-dim);font-size:0.9rem;">Host submits the team row.</div>'}
        </div>
      ` : ''}

      ${completedAt ? `
        <div style="margin-top:10px;color:var(--success);font-weight:600;">
          Completed at ${new Date(completedAt).toLocaleTimeString()}.
        </div>
      ` : ''}
    </div>

    <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:var(--radius);padding:20px;">
      <h3 style="font-family:'Fraunces',serif;font-size:1.2rem;margin-bottom:10px;">Team Progress</h3>
      <div style="color:var(--text-dim);font-size:0.9rem;margin-bottom:10px;">
        Elapsed: ${elapsedSec}s â€¢ Score: <strong style="color:var(--accent);">${score}</strong>
      </div>
      ${participation.map(p => `
        <div style="display:flex;justify-content:space-between;align-items:center;background:var(--surface-2);
          border-radius:10px;padding:10px 12px;margin-bottom:8px;">
          <div style="display:flex;align-items:center;gap:10px;">
            <span>${escapeHtml(p.avatar)}</span>
            <span>${escapeHtml(p.name)}</span>
          </div>
          <div style="font-size:0.85rem;color:var(--text-mid);text-align:right;">
            ${p.suggestion ? `suggested <strong>${escapeHtml(p.suggestion)}</strong>` : 'no suggestion'}
            ${p.vote ? ` â€¢ voted <strong>${escapeHtml(p.vote)}</strong>` : ''}
          </div>
        </div>
      `).join('')}
    </div>

    ${isHost ? `
      <button class="btn-primary" data-action="new-word-chain-puzzle" style="margin-top:16px;">
        New Word Chain Puzzle
      </button>
    ` : ''}
  `;
}

function generateBrainstormNoteId() {
  return `note_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}

async function brainstormAddNote() {
  if (!APP.roomCode || APP.room?.currentActivity !== 'brainstorm-canvas') return;
  const text = String(document.getElementById('brainNoteText')?.value || '').trim().slice(0, 200);
  const lane = String(document.getElementById('brainNoteLane')?.value || 'start');
  if (!text) {
    showError('Enter an idea before adding a note.');
    return;
  }
  if (!BRAINSTORM_LANE_INDEX.hasOwnProperty(lane)) {
    showError('Choose a valid lane.');
    return;
  }

  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'brainstorm-canvas') return;
  const state = room.activityState || {};
  if (state.sessionStatus === 'locked') {
    showError('Canvas is locked by host.');
    return;
  }
  state.notes = Array.isArray(state.notes) ? state.notes : [];
  const noteId = generateBrainstormNoteId();
  state.notes.unshift({
    id: noteId,
    text,
    author: APP.player.name,
    lane,
    votes: 0,
    voters: [],
    color: BRAINSTORM_NOTE_COLORS[Math.floor(Math.random() * BRAINSTORM_NOTE_COLORS.length)],
    createdAt: Date.now(),
    updatedAt: Date.now()
  });
  await awardParticipationInput(room, `brainstorm_note:${noteId}:${APP.player.name}`, 5);
  room.activityState = state;
  room.brainstormData = safeParseJson(JSON.stringify(state)) || state;
  room.brainstormLastUpdatedAt = Date.now();
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function brainstormToggleVote(noteId) {
  if (!APP.roomCode || !noteId || APP.room?.currentActivity !== 'brainstorm-canvas') return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'brainstorm-canvas') return;
  const state = room.activityState || {};
  if (state.sessionStatus === 'locked') return;
  const notes = Array.isArray(state.notes) ? state.notes : [];
  const note = notes.find(item => item.id === noteId);
  if (!note) return;
  note.voters = Array.isArray(note.voters) ? note.voters : [];
  const idx = note.voters.indexOf(APP.player.name);
  if (idx >= 0) {
    note.voters.splice(idx, 1);
  } else {
    note.voters.push(APP.player.name);
    await awardParticipationInput(room, `brainstorm_vote:${noteId}:${APP.player.name}`, 1);
  }
  note.votes = note.voters.length;
  note.updatedAt = Date.now();
  state.notes = notes;
  room.activityState = state;
  room.brainstormData = safeParseJson(JSON.stringify(state)) || state;
  room.brainstormLastUpdatedAt = Date.now();
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function brainstormMoveNote(noteId, lane) {
  if (!APP.roomCode || !noteId || !BRAINSTORM_LANE_INDEX.hasOwnProperty(lane) || APP.room?.currentActivity !== 'brainstorm-canvas') return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'brainstorm-canvas') return;
  const state = room.activityState || {};
  if (state.sessionStatus === 'locked') return;
  const notes = Array.isArray(state.notes) ? state.notes : [];
  const note = notes.find(item => item.id === noteId);
  if (!note) return;
  note.lane = lane;
  note.updatedAt = Date.now();
  room.activityState = state;
  room.brainstormData = safeParseJson(JSON.stringify(state)) || state;
  room.brainstormLastUpdatedAt = Date.now();
  await RoomManager.updateRoom(APP.roomCode, room);
}

async function brainstormShiftNote(noteId, direction) {
  const room = APP.room;
  if (!room || room.currentActivity !== 'brainstorm-canvas') return;
  const notes = Array.isArray(room.activityState?.notes) ? room.activityState.notes : [];
  const note = notes.find(item => item.id === noteId);
  if (!note) return;
  const laneIndex = BRAINSTORM_LANE_INDEX[note.lane];
  if (!Number.isInteger(laneIndex)) return;
  const nextIndex = direction === 'left' ? laneIndex - 1 : laneIndex + 1;
  if (nextIndex < 0 || nextIndex >= BRAINSTORM_LANES.length) return;
  await brainstormMoveNote(noteId, BRAINSTORM_LANES[nextIndex].id);
}

async function brainstormToggleLock() {
  if (!APP.roomCode || !APP.room || APP.room.host !== APP.player?.name || APP.room.currentActivity !== 'brainstorm-canvas') return;
  const room = await RoomManager.loadRoom(APP.roomCode);
  if (!room || room.currentActivity !== 'brainstorm-canvas') return;
  const state = room.activityState || {};
  state.sessionStatus = state.sessionStatus === 'locked' ? 'open' : 'locked';
  room.activityState = state;
  room.brainstormData = safeParseJson(JSON.stringify(state)) || state;
  room.brainstormLastUpdatedAt = Date.now();
  await RoomManager.updateRoom(APP.roomCode, room);
}

function triggerTextFileDownload(filename, mimeType, content) {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  link.remove();
  setTimeout(() => URL.revokeObjectURL(url), 0);
}

function getBrainstormExportSnapshot() {
  const state = APP.room?.currentActivity === 'brainstorm-canvas'
    ? (APP.room.activityState || {})
    : (APP.room?.brainstormData || {});
  const notes = Array.isArray(state.notes)
    ? state.notes.map(note => ({ ...note, voters: Array.isArray(note.voters) ? [...note.voters] : [] }))
    : [];
  return {
    exportedAt: new Date().toISOString(),
    roomCode: APP.roomCode || '',
    boardType: state.boardType || 'start-stop-improve-create',
    sessionStatus: state.sessionStatus || 'open',
    notes
  };
}

async function exportBrainstormData(format) {
  if (!APP.roomCode || !APP.room) return;
  const snapshot = getBrainstormExportSnapshot();
  if (!Array.isArray(snapshot.notes) || snapshot.notes.length === 0) {
    showError('No brainstorm notes to export yet.');
    return;
  }
  const stamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
  const safeRoom = String(snapshot.roomCode || 'session').replace(/[^a-zA-Z0-9_-]/g, '');

  if (format === 'json') {
    const filename = `brainstorm-${safeRoom || 'session'}-${stamp}.json`;
    triggerTextFileDownload(filename, 'application/json;charset=utf-8', JSON.stringify(snapshot, null, 2));
    return;
  }

  if (format === 'csv') {
    const header = ['id', 'lane', 'text', 'author', 'votes', 'voters', 'createdAt', 'updatedAt'];
    const escapeCell = value => `"${String(value ?? '').replace(/"/g, '""')}"`;
    const rows = snapshot.notes.map(note => [
      note.id || '',
      note.lane || '',
      note.text || '',
      note.author || '',
      Number(note.votes || 0),
      Array.isArray(note.voters) ? note.voters.join('|') : '',
      note.createdAt ? new Date(note.createdAt).toISOString() : '',
      note.updatedAt ? new Date(note.updatedAt).toISOString() : ''
    ]);
    const csv = [header.map(escapeCell).join(','), ...rows.map(row => row.map(escapeCell).join(','))].join('\n');
    const filename = `brainstorm-${safeRoom || 'session'}-${stamp}.csv`;
    triggerTextFileDownload(filename, 'text/csv;charset=utf-8', csv);
  }
}

function getPulseExportSnapshot() {
  const state = APP.room?.activityState || {};
  const selected = Array.isArray(state.selectedPollIndexes) ? state.selectedPollIndexes : [];
  const resultIndexes = selected.length ? selected : PULSE_QUESTIONS.map((_, idx) => idx);
  const voteHistory = state.voteHistory && typeof state.voteHistory === 'object' ? { ...state.voteHistory } : {};
  const currentPoll = Number.isInteger(state.currentPoll) ? state.currentPoll : 0;

  // Include the in-progress poll in export when results are not finalized yet.
  if (!state.showResults && state.votes && typeof state.votes === 'object' && !voteHistory[currentPoll]) {
    voteHistory[currentPoll] = { ...state.votes };
  }

  const polls = resultIndexes.map((sourceIndex, displayIndex) => {
    const poll = PULSE_QUESTIONS[sourceIndex];
    if (!poll) return null;
    const pollVotes = voteHistory[displayIndex] && typeof voteHistory[displayIndex] === 'object'
      ? voteHistory[displayIndex]
      : {};
    const counts = {};
    Object.values(pollVotes).forEach(value => {
      counts[value] = (counts[value] || 0) + 1;
    });
    const totalVotes = Object.keys(pollVotes).length;
    return {
      order: displayIndex + 1,
      question: poll.q,
      totalVotes,
      options: poll.opts.map((option, optionIndex) => {
        const votes = counts[optionIndex] || 0;
        const percent = totalVotes > 0 ? Math.round((votes / totalVotes) * 100) : 0;
        return {
          optionIndex,
          option,
          votes,
          percent
        };
      })
    };
  }).filter(Boolean);

  return {
    exportedAt: new Date().toISOString(),
    roomCode: APP.roomCode || '',
    activity: 'pulse-check',
    showResults: Boolean(state.showResults),
    totalParticipants: Array.isArray(APP.room?.participants) ? APP.room.participants.length : 0,
    polls
  };
}

async function exportPulseCheckData(format) {
  if (!APP.roomCode || APP.room?.currentActivity !== 'pulse-check') return;
  const snapshot = getPulseExportSnapshot();
  if (!Array.isArray(snapshot.polls) || snapshot.polls.length === 0) {
    showError('No pulse data to export yet.');
    return;
  }
  const stamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
  const safeRoom = String(snapshot.roomCode || 'session').replace(/[^a-zA-Z0-9_-]/g, '');

  if (format === 'json') {
    const filename = `pulse-check-${safeRoom || 'session'}-${stamp}.json`;
    triggerTextFileDownload(filename, 'application/json;charset=utf-8', JSON.stringify(snapshot, null, 2));
    return;
  }

  if (format === 'csv') {
    const header = ['pollOrder', 'question', 'optionIndex', 'option', 'votes', 'percent', 'totalVotes'];
    const escapeCell = value => `"${String(value ?? '').replace(/"/g, '""')}"`;
    const rows = [];
    snapshot.polls.forEach(poll => {
      poll.options.forEach(option => {
        rows.push([
          poll.order,
          poll.question,
          option.optionIndex,
          option.option,
          option.votes,
          option.percent,
          poll.totalVotes
        ]);
      });
    });
    const csv = [header.map(escapeCell).join(','), ...rows.map(row => row.map(escapeCell).join(','))].join('\n');
    const filename = `pulse-check-${safeRoom || 'session'}-${stamp}.csv`;
    triggerTextFileDownload(filename, 'text/csv;charset=utf-8', csv);
  }
}

function renderBrainstormCanvas() {
  const isHost = APP.room.host === APP.player.name;
  const safeRoomCode = escapeHtml(APP.roomCode);
  const state = APP.room.activityState || {};
  const notes = Array.isArray(state.notes) ? state.notes : [];
  const sessionLocked = state.sessionStatus === 'locked';

  const notesByLane = Object.fromEntries(BRAINSTORM_LANES.map(lane => [lane.id, []]));
  notes.forEach(note => {
    const laneId = BRAINSTORM_LANE_INDEX.hasOwnProperty(note.lane) ? note.lane : 'start';
    notesByLane[laneId].push(note);
  });
  Object.values(notesByLane).forEach(list => list.sort((a, b) => (b.votes || 0) - (a.votes || 0) || (b.createdAt || 0) - (a.createdAt || 0)));

  return `
    <div class="header">
      <h1 style="font-size:2rem;font-weight:700;">ğŸ§© Brainstorm Canvas</h1>
      <p class="tagline">Start â€¢ Stop â€¢ Improve â€¢ Create â€¢ Room: ${safeRoomCode}</p>
    </div>

    ${isHost ? '<button class="btn-secondary" data-action="end-activity">â† End Activity</button>' : ''}

    <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:var(--radius);padding:16px;">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;">
        <div style="color:${sessionLocked ? 'var(--warning)' : 'var(--success)'};font-weight:700;">
          ${sessionLocked ? 'Canvas Locked' : 'Canvas Open'}
        </div>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
          ${isHost ? `<button class="btn-secondary" data-action="brainstorm-toggle-lock">${sessionLocked ? 'Unlock Canvas' : 'Lock Canvas'}</button>` : ''}
          <button class="btn-secondary" data-action="brainstorm-export-json">Export JSON</button>
          <button class="btn-secondary" data-action="brainstorm-export-csv">Export CSV</button>
        </div>
      </div>

      <div class="brain-board">
        ${BRAINSTORM_LANES.map(lane => `
          <div class="brain-lane" data-brain-lane="${lane.id}">
            <div class="brain-lane-header">
              <span>${lane.icon} ${escapeHtml(lane.label)}</span>
              <span style="font-size:0.8rem;color:var(--text-dim);">${notesByLane[lane.id].length}</span>
            </div>
            ${notesByLane[lane.id].length ? `
              <div class="brain-lane-notes">
                ${notesByLane[lane.id].map(note => {
                  const voted = Array.isArray(note.voters) && note.voters.includes(APP.player.name);
                  const color = /^#[0-9a-fA-F]{6}$/.test(note.color || '') ? note.color : '#fef3a7';
                  return `
                    <div class="brain-note" draggable="${sessionLocked ? 'false' : 'true'}" data-note-id="${note.id}" style="background:${escapeHtml(color)};">
                      <div style="font-weight:600;white-space:pre-wrap;">${escapeHtml(note.text || '')}</div>
                      <div class="brain-note-meta">
                        <span>by ${escapeHtml(note.author || 'anon')}</span>
                        <button class="brain-vote-btn ${voted ? 'voted' : ''}" data-action="brainstorm-toggle-vote" data-note-id="${note.id}" ${sessionLocked ? 'disabled' : ''}>
                          ğŸ‘ ${Number(note.votes || 0)}
                        </button>
                      </div>
                      <div class="brain-note-controls">
                        <button class="btn-secondary" data-action="brainstorm-shift-note" data-note-id="${note.id}" data-direction="left" ${sessionLocked ? 'disabled' : ''}>â†</button>
                        <button class="btn-secondary" data-action="brainstorm-shift-note" data-note-id="${note.id}" data-direction="right" ${sessionLocked ? 'disabled' : ''}>â†’</button>
                      </div>
                    </div>
                  `;
                }).join('')}
              </div>
            ` : '<div style="color:var(--text-dim);font-size:0.85rem;">No ideas yet.</div>'}
          </div>
        `).join('')}
      </div>

      <div style="margin-top:14px;border-top:1px solid var(--border);padding-top:14px;">
        <div style="display:grid;grid-template-columns:1.5fr 1fr auto;gap:8px;">
          <input id="brainNoteText" class="form-input" maxlength="200" placeholder="Add a sticky note idea..." ${sessionLocked ? 'disabled' : ''}>
          <select id="brainNoteLane" class="form-input" ${sessionLocked ? 'disabled' : ''}>
            ${BRAINSTORM_LANES.map(lane => `<option value="${lane.id}">${escapeHtml(lane.label)}</option>`).join('')}
          </select>
          <button class="btn-primary" data-action="brainstorm-add-note" ${sessionLocked ? 'disabled' : ''} style="width:auto;padding:10px 16px;">Add</button>
        </div>
      </div>
    </div>
  `;
}

function renderEmojiCharadesResults() {
  const state = APP.room.activityState || {};
  const isHost = APP.room.host === APP.player.name;
  const participants = APP.room.participants.map(p => ({
    ...p,
    score: state.scores?.[p.name] || 0
  })).sort((a, b) => b.score - a.score);

  return `
    <div class="header">
      <h1 style="font-size:2.2rem;font-weight:700;">ğŸ­ Emoji Charades Results</h1>
      <p class="tagline">Final scores</p>
    </div>

    <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:var(--radius);padding:24px;">
      ${participants.map((p, idx) => `
        <div style="display:flex;justify-content:space-between;align-items:center;background:var(--surface-2);border-radius:10px;padding:12px 14px;margin-bottom:8px;">
          <div style="display:flex;align-items:center;gap:10px;">
            <span style="font-weight:700;min-width:30px;">#${idx + 1}</span>
            <span>${escapeHtml(p.avatar)}</span>
            <span style="font-weight:600;">${escapeHtml(p.name)}</span>
          </div>
          <span style="font-weight:700;color:var(--accent);">${p.score}</span>
        </div>
      `).join('')}
    </div>

    ${isHost ? `
      <div style="display:flex;gap:10px;margin-top:14px;">
        <button class="btn-primary" data-action="new-emoji-charades-round" style="flex:1;">Play Again</button>
        <button class="btn-secondary" data-action="end-activity" style="flex:1;">Back to Lobby</button>
      </div>
    ` : ''}
  `;
}

function renderEmojiCharades() {
  const state = APP.room.activityState || {};
  const isHost = APP.room.host === APP.player.name;
  const round = Number.isInteger(state.round) ? state.round : 0;
  const roundsTotal = Math.max(1, Math.min(8, Number.parseInt(state.roundsTotal || '8', 10) || 8));
  const questionIndex = state.questionOrder?.[round] ?? round;
  const prompt = EMOJI_CHARADES_BANK[questionIndex];

  if (!prompt || round >= roundsTotal) {
    return renderEmojiCharadesResults();
  }

  const revealed = Boolean(state.revealed);
  const guesses = state.guesses || {};
  const userGuess = guesses[APP.player.name] || '';
  const roundPoints = state.roundPoints || {};
  const answerKey = normalizeCharadesAnswer(prompt.answer);
  const submittedCount = Object.values(guesses).filter(Boolean).length;

  const guessRows = APP.room.participants.map(player => {
    const guess = guesses[player.name] || '';
    const score = roundPoints[player.name] || 0;
    const guessKey = normalizeCharadesAnswer(guess);
    const isCorrect = revealed && guess && guessKey === answerKey;
    const statusChip = !revealed
      ? (guess ? '<span class="emoji-charades-chip" style="background:rgba(0,210,211,0.12);color:var(--accent);">Submitted</span>' : '<span class="emoji-charades-chip" style="background:var(--surface);color:var(--text-dim);">Waiting</span>')
      : (isCorrect
        ? `<span class="emoji-charades-chip" style="background:rgba(0,210,106,0.14);color:var(--success);">âœ“ Correct +${score}</span>`
        : '<span class="emoji-charades-chip" style="background:rgba(255,64,96,0.12);color:var(--danger);">âœ• Miss</span>');
    return `
      <div style="display:flex;justify-content:space-between;align-items:center;background:var(--surface-2);border:1px solid var(--border);border-radius:10px;padding:10px 12px;margin-bottom:8px;">
        <div style="display:flex;align-items:center;gap:8px;min-width:0;">
          <span>${escapeHtml(player.avatar)}</span>
          <span style="font-weight:600;">${escapeHtml(player.name)}</span>
          ${revealed ? `<span style="color:var(--text-mid);font-size:0.86rem;">${guess ? escapeHtml(guess) : 'No guess'}</span>` : ''}
        </div>
        ${statusChip}
      </div>
    `;
  }).join('');

  return `
    <div class="header">
      <h1 style="font-size:2rem;font-weight:700;">ğŸ­ Emoji Charades</h1>
      <p class="tagline">Round ${Math.min(round + 1, roundsTotal)} of ${roundsTotal} â€¢ Guess the phrase from emojis</p>
    </div>

    ${isHost ? '<button class="btn-secondary" data-action="end-activity">â† End Activity</button>' : ''}

    <div style="background:var(--surface-solid);border:2px solid var(--accent);border-radius:var(--radius);padding:28px;margin:20px 0;text-align:center;">
      <div class="emoji-charades-prompt">${escapeHtml(prompt.emojis)}</div>
      ${revealed ? `
        <div style="margin-top:16px;color:var(--text-mid);font-size:0.9rem;">Answer</div>
        <div style="font-family:'Fraunces',serif;font-size:1.6rem;color:var(--success);margin-top:6px;">${escapeHtml(prompt.answer)}</div>
      ` : ''}
    </div>

    ${!revealed ? `
      <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:14px;padding:16px;margin-bottom:14px;">
        <label class="form-label" for="emojiCharadesGuessInput">Your guess</label>
        <div class="emoji-charades-guess-row">
          <input id="emojiCharadesGuessInput" class="form-input" maxlength="60" value="${escapeHtml(userGuess)}" placeholder="Type a phrase">
          <button class="btn-primary" data-action="submit-emoji-charades-guess" style="width:auto;padding:0 16px;">Submit</button>
        </div>
        <div style="font-size:0.84rem;color:var(--text-dim);margin-top:10px;">${submittedCount} of ${APP.room.participants.length} submitted</div>
      </div>
    ` : ''}

    <div style="background:var(--surface-solid);border:1px solid var(--border);border-radius:14px;padding:16px;margin-bottom:14px;">
      <h3 style="margin-bottom:10px;">Team Guesses</h3>
      ${guessRows}
    </div>

    ${isHost ? `
      <button class="btn-primary" data-action="${revealed ? 'next-emoji-charades' : 'reveal-emoji-charades'}">
        ${revealed ? (round < roundsTotal - 1 ? 'Next Round' : 'View Results') : 'Reveal Answer'}
      </button>
    ` : ''}
  `;
}

function renderRegularTrivia() {
  const state = APP.room.activityState || {};
  const currentQ = state.currentQ || 0;
  const questionIndex = state.questionOrder?.[currentQ] ?? currentQ;
  const question = TRIVIA_BANK[questionIndex];
  const revealed = state.revealed || false;
  const answers = state.answers || {};
  const userAnswer = answers[APP.player.name];
  const isHost = APP.room.host === APP.player.name;
  const hostSettings = getRoomHostSettings(APP.room);
  const safeRoomCode = escapeHtml(APP.roomCode);
  
  if (!question) {
    return renderTriviaResults();
  }
  
  let optionsHtml = '';
  question.opts.forEach((opt, i) => {
    const isCorrect = revealed && i === question.ans;
    const isUserAnswer = userAnswer === i;
    const canClick = !revealed && (hostSettings.allowAnswerChanges || userAnswer === undefined || userAnswer === null);
    const voteCount = revealed ? Object.values(answers).filter(a => a === i).length : 0;
    
    let style = '';
    if (isCorrect) {
      style = 'background:rgba(0,210,106,0.15);border:2px solid var(--success);';
    } else if (isUserAnswer && !revealed) {
      style = 'background:rgba(0,210,211,0.06);border:2px solid var(--accent);';
    } else if (revealed) {
      style = 'background:var(--surface-2);border:2px solid var(--border);opacity:0.5;';
    } else {
      style = 'background:var(--surface-2);border:2px solid var(--border);';
    }
    
    const actionAttrs = canClick ? `data-action="submit-regular-trivia-answer" data-index="${i}"` : '';
    const disabledAttr = canClick ? '' : 'disabled';
    const cursor = canClick ? 'pointer' : 'default';
    
    optionsHtml += `
      <button type="button" class="tile-btn" ${actionAttrs} ${disabledAttr}
        style="${style}border-radius:12px;padding:16px 20px;margin-bottom:12px;
        cursor:${cursor};transition:all 0.3s;display:flex;justify-content:space-between;
        align-items:center;">
        <span style="font-size:1.1rem;">${opt}</span>
        ${revealed ? `
          <span style="background:var(--accent);color:var(--bg);padding:6px 14px;
            border-radius:20px;font-size:0.85rem;font-weight:700;">${voteCount}</span>
        ` : ''}
      </button>
    `;
  });
  
  return `
    <div class="header">
      <h1 style="font-size:2rem;font-weight:700;">ğŸ§  Trivia Battle</h1>
      <p class="tagline">Question ${currentQ + 1} of ${TRIVIA_BANK.length} â€¢ Room: ${safeRoomCode}</p>
    </div>
    
    ${isHost ? '<button class="btn-secondary" data-action="end-activity">â† End Activity</button>' : ''}
    
    <div style="background:var(--surface-solid);border:2px solid var(--accent);
      border-radius:var(--radius);padding:40px 30px;margin:30px 0;text-align:center;">
      <div style="font-family:'Fraunces',serif;font-size:${APP.presentationMode ? '2.5rem' : '1.8rem'};
        font-weight:700;line-height:1.4;">
        ${question.q}
      </div>
    </div>
    
    <div style="max-width:700px;margin:0 auto;">
      ${optionsHtml}
    </div>
    
    <div role="status" aria-live="polite" aria-atomic="true" style="text-align:center;padding:16px;color:var(--text-dim);margin-top:20px;">
      ${Object.keys(answers).length} of ${APP.room.participants.length} answered
    </div>
    
    ${isHost ? `
      <button class="btn-primary" data-action="${revealed ? 'next-regular-trivia' : 'reveal-regular-answer'}">
        ${revealed ? (currentQ < TRIVIA_BANK.length - 1 ? 'Next Question' : 'View Final Results') : 'Reveal Answer'}
      </button>
    ` : ''}
  `;
}

function renderLightningTrivia() {
  const state = APP.room.activityState || {};
  const currentQ = state.currentQ || 0;
  const questionIndex = state.questionOrder?.[currentQ] ?? currentQ;
  const question = TRIVIA_BANK[questionIndex];
  const revealed = state.revealed || false;
  const answers = state.answers || {};
  const reactions = (state.reactions || []).filter(r => Date.now() - (r.ts || 0) < 6000);
  const userAnswer = answers[APP.player.name];
  const isHost = APP.room.host === APP.player.name;
  const hostSettings = getRoomHostSettings(APP.room);
  const safeRoomCode = escapeHtml(APP.roomCode);
  
  if (!question) {
    return renderTriviaResults();
  }
  
  const startTime = state.startTime || Date.now();
  const timeLimit = 20;
  const timeElapsed = (Date.now() - startTime) / 1000;
  const timeRemaining = Math.max(0, timeLimit - timeElapsed);
  const progress = (timeRemaining / timeLimit) * 100;
  const circumference = 2 * Math.PI * 50;
  const strokeDashoffset = circumference - (progress / 100) * circumference;
  
  const colors = ['kahoot-red', 'kahoot-blue', 'kahoot-yellow', 'kahoot-green'];
  
  let answerButtons = '';
  question.opts.forEach((opt, i) => {
    const colorClass = colors[i];
    let buttonClass = 'kahoot-answer ' + colorClass;
    const isCorrect = revealed && i === question.ans;
    const isUserAnswer = userAnswer === i;
    const isWrongUserAnswer = revealed && isUserAnswer && !isCorrect;
    const canClick = !revealed && (hostSettings.allowAnswerChanges || userAnswer === undefined || userAnswer === null);
    
    if (revealed) {
      buttonClass += ' disabled';
      if (isCorrect) buttonClass += ' correct';
      else if (!isCorrect) buttonClass += ' wrong';
    } else if (isUserAnswer) {
      buttonClass += ' selected';
    }
    
    const actionAttrs = canClick ? `data-action="submit-answer" data-index="${i}"` : '';
    const disabledAttr = canClick ? '' : 'disabled';
    
    const badge = !revealed
      ? (isUserAnswer ? '<span class="kahoot-selected-badge" aria-hidden="true">âœ“</span>' : '')
      : (isCorrect
        ? '<span class="kahoot-selected-badge" aria-hidden="true" style="background:var(--success);">âœ“</span>'
        : (isWrongUserAnswer
          ? '<span class="kahoot-selected-badge" aria-hidden="true" style="background:var(--danger);">âœ•</span>'
          : ''));

    const revealStyle = revealed
      ? (isCorrect
        ? 'box-shadow:0 0 0 4px rgba(0,210,106,0.55),0 0 28px rgba(0,210,106,0.35);transform:scale(1.03);'
        : (isWrongUserAnswer
          ? 'box-shadow:0 0 0 3px rgba(255,64,96,0.45),0 0 18px rgba(255,64,96,0.22);'
          : 'opacity:0.45;'))
      : '';

    answerButtons += `
      <button type="button" class="${buttonClass}" ${actionAttrs} ${disabledAttr} aria-pressed="${isUserAnswer ? 'true' : 'false'}" style="${revealStyle}">
        ${badge}
        ${String.fromCharCode(65 + i)}. ${opt}
      </button>
    `;
  });
  
  let leaderboardHtml = '';
  if (revealed) {
    const participants = APP.room.participants.map(p => ({
      ...p,
      score: state.scores?.[p.name] || 0,
      lastPoints: state.lastPoints?.[p.name] || 0
    })).sort((a, b) => b.score - a.score);
    
    participants.forEach((p, i) => {
      const lastPts = p.lastPoints > 0 ? `<span style="color:var(--success);font-size:0.85rem;margin-left:8px;">+${p.lastPoints}</span>` : '';
      leaderboardHtml += `
        <div style="display:flex;justify-content:space-between;align-items:center;
          background:var(--surface-2);border-radius:10px;padding:14px;margin-bottom:10px;">
          <div style="display:flex;align-items:center;gap:12px;">
            <span style="font-size:1.5rem;font-weight:700;width:40px;">#${i + 1}</span>
            <span style="font-size:1.2rem;">${escapeHtml(p.avatar)}</span>
            <span style="font-weight:600;">${escapeHtml(p.name)}</span>
            ${lastPts}
          </div>
          <span style="background:var(--accent);color:var(--bg);padding:6px 14px;border-radius:20px;font-weight:700;">
            ${p.score}
          </span>
        </div>
      `;
    });
  }

  const reactionButtons = LIGHTNING_REACTIONS.map(emoji => `
    <button type="button" class="reaction-btn" data-action="send-lightning-reaction" data-emoji="${emoji}" aria-label="Send reaction ${emoji}">
      ${emoji}
    </button>
  `).join('');

  const reactionStream = reactions.map(r => {
    const player = APP.room.participants.find(p => p.name === r.player);
    const avatar = player?.avatar || 'ğŸ‘¤';
    return `<span class="reaction-pill" title="${escapeHtml(r.player)}">${escapeHtml(avatar)} ${escapeHtml(r.emoji)}</span>`;
  }).join('');
  
  return `
    <div class="header">
      <h1 style="font-size:2rem;font-weight:700;margin-bottom:5px;">âš¡ Lightning Trivia</h1>
      <p class="tagline">Question ${currentQ + 1} of ${TRIVIA_BANK.length} â€¢ Room: ${safeRoomCode}</p>
    </div>
    
    ${isHost ? '<button class="btn-secondary" data-action="end-activity">â† End Activity</button>' : ''}
    
    ${!revealed ? `
      <div class="kahoot-timer">
        <svg class="timer-circle" viewBox="0 0 120 120">
          <circle class="timer-bg" cx="60" cy="60" r="50"/>
          <circle class="timer-progress ${timeRemaining < 5 ? 'warning' : ''}" 
            cx="60" cy="60" r="50"
            stroke-dasharray="${circumference}"
            stroke-dashoffset="${strokeDashoffset}"/>
        </svg>
        <div class="timer-text" role="timer" aria-live="off" aria-label="${Math.ceil(timeRemaining)} seconds remaining" style="color:${timeRemaining < 5 ? 'var(--danger)' : 'var(--accent)'}">
          ${timeRemaining.toFixed(1)}
        </div>
      </div>
    ` : ''}

    <div class="reaction-stream" aria-live="polite">${reactionStream}</div>
    <div class="reaction-bar">${reactionButtons}</div>
    
    <div style="background:var(--surface-solid);border:2px solid var(--accent);
      border-radius:var(--radius);padding:40px 30px;margin-bottom:30px;text-align:center;">
      <div style="font-family:'Fraunces',serif;font-size:${APP.presentationMode ? '2.5rem' : '1.8rem'};
        font-weight:700;line-height:1.4;margin-bottom:30px;">
        ${question.q}
      </div>
      
      <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:16px;max-width:800px;margin:0 auto;">
        ${answerButtons}
      </div>
    </div>
    
    ${!revealed ? `
      <div role="status" aria-live="polite" aria-atomic="true" style="text-align:center;color:var(--text-dim);margin-bottom:20px;">
        ${Object.keys(answers).length} of ${APP.room.participants.length} answered
      </div>
    ` : `
      <div style="background:var(--surface-solid);border:1px solid var(--border);
        border-radius:var(--radius);padding:24px;margin-bottom:20px;">
        <h3 aria-live="polite" aria-atomic="true" style="text-align:center;font-family:'Fraunces',serif;font-size:1.3rem;margin-bottom:20px;">
          ğŸ† Leaderboard
        </h3>
        ${leaderboardHtml}
      </div>
    `}
    
    ${isHost ? `
      <button class="btn-primary" data-action="${revealed ? 'next-question' : 'reveal-answer'}">
        ${revealed ? (currentQ < TRIVIA_BANK.length - 1 ? 'Next Question' : 'View Final Results') : 'Reveal Answer'}
      </button>
    ` : ''}
  `;
}

function renderTriviaResults() {
  const finishedActivity = APP.room.currentActivity;
  const isLightningResults = finishedActivity === 'lightning-trivia';
  const participants = APP.room.participants.map(p => ({
    ...p,
    score: APP.room.activityState.scores?.[p.name] || 0
  })).sort((a, b) => b.score - a.score);
  
  const top3 = participants.slice(0, 3);
  const isHost = APP.room.host === APP.player.name;
  const confettiPalette = ['#00d2d3', '#c56cf0', '#feca57', '#00d26a', '#ff4060', '#ffd700'];
  const confettiPieces = isLightningResults
    ? Array.from({ length: 42 }, (_, idx) => {
      const left = Math.floor(Math.random() * 100);
      const delay = (Math.random() * 2).toFixed(2);
      const duration = (7.2 + (Math.random() * 2.8)).toFixed(2);
      const drift = Math.floor((Math.random() * 160) - 80);
      const rotate = Math.floor(Math.random() * 70) - 35;
      const color = confettiPalette[idx % confettiPalette.length];
      return `<span class="trivia-confetti-piece" style="left:${left}%;background:${color};animation-delay:${delay}s;animation-duration:${duration}s;--confetti-drift:${drift}px;transform:rotate(${rotate}deg);"></span>`;
    }).join('')
    : '';
  
  return `
    ${isLightningResults ? `<div class="trivia-confetti" aria-hidden="true">${confettiPieces}</div>` : ''}
    <div class="header">
      <h1 style="font-size:2.5rem;font-weight:700;margin-bottom:10px;">ğŸ‰ Game Over!</h1>
      <p class="tagline">${finishedActivity === 'regular-trivia' ? 'Trivia Battle Results' : 'Lightning Trivia Results'}</p>
    </div>
    
    ${top3.length >= 3 ? `
      <div class="podium">
        <div class="podium-place second">
          <div class="podium-medal">ğŸ¥ˆ</div>
          <div style="font-size:1.5rem;margin-bottom:5px;">${escapeHtml(top3[1].avatar)}</div>
          <div style="font-weight:700;">${escapeHtml(top3[1].name)}</div>
          <div style="color:var(--accent);font-size:1.2rem;font-weight:700;margin-top:8px;">
            ${top3[1].score}
          </div>
        </div>
        
        <div class="podium-place first">
          <div class="podium-medal">ğŸ¥‡</div>
          <div style="font-size:2rem;margin-bottom:5px;">${escapeHtml(top3[0].avatar)}</div>
          <div style="font-weight:700;font-size:1.1rem;">${escapeHtml(top3[0].name)}</div>
          <div style="color:#ffd700;font-size:1.5rem;font-weight:700;margin-top:8px;">
            ${top3[0].score}
          </div>
        </div>
        
        <div class="podium-place third">
          <div class="podium-medal">ğŸ¥‰</div>
          <div style="font-size:1.5rem;margin-bottom:5px;">${escapeHtml(top3[2].avatar)}</div>
          <div style="font-weight:700;">${escapeHtml(top3[2].name)}</div>
          <div style="color:var(--warning);font-size:1.2rem;font-weight:700;margin-top:8px;">
            ${top3[2].score}
          </div>
        </div>
      </div>
    ` : ''}
    
    <div style="background:var(--surface-solid);border:1px solid var(--border);
      border-radius:var(--radius);padding:24px;margin:30px 0;">
      <h3 style="text-align:center;margin-bottom:20px;font-size:1.2rem;font-weight:700;">
        Final Standings
      </h3>
      ${participants.map((p, i) => `
        <div style="display:flex;justify-content:space-between;align-items:center;
          background:var(--surface-2);border-radius:10px;padding:14px;margin-bottom:10px;">
          <div style="display:flex;align-items:center;gap:12px;">
            <span style="font-size:1.3rem;font-weight:700;">#${i + 1}</span>
            <span style="font-size:1.2rem;">${escapeHtml(p.avatar)}</span>
            <span style="font-weight:600;">${escapeHtml(p.name)}</span>
          </div>
          <span style="font-size:1.2rem;font-weight:700;color:var(--accent);">${p.score}</span>
        </div>
      `).join('')}
    </div>
    
    ${isHost ? `
      <div style="display:flex;gap:10px;">
        <button class="btn-primary" data-action="play-again" style="flex:1;">Play Again</button>
        <button class="btn-secondary" data-action="end-activity" style="flex:1;">Back to Lobby</button>
      </div>
    ` : ''}
  `;
}

// Initialize
async function init() {
  const params = new URLSearchParams(window.location.search);
  const deepJoinCode = normalizeRoomCode(params.get('join') || params.get('room') || params.get('code') || '');
  if (/^[A-Z0-9]{6}$/.test(deepJoinCode)) {
    APP.pendingJoinCode = deepJoinCode;
  }
  getFeedbackUserToken();
  await loadPublicConfig();
  const profile = await PlayerManager.loadProfile();
  if (profile) {
    APP.player = profile;
    APP.screen = APP.pendingJoinCode ? 'join-room' : 'dashboard';
  }
  render();
}

window.addEventListener('beforeunload', () => {
  stopRoomSync();
});

init();

// --- MISSING RENDER SCREENS ---
function renderScheduleMeeting() {
  return `
    <div class="header">
      <h1 class="logo">Schedule Team Meeting</h1>
      <p class="tagline">Set up a date, time, Zoom link, meeting details, and Activity Queue</p>
    </div>
    <div class="form-container">
      <div class="form-group">
        <label class="form-label" for="meetingDate">Date</label>
        <input type="date" id="meetingDate" class="form-input">
      </div>
      <div class="form-group">
        <label class="form-label" for="meetingTime">Time</label>
        <input type="time" id="meetingTime" class="form-input">
      </div>
      <div class="form-group">
        <label class="form-label" for="zoomLink">Zoom Meeting Link</label>
        <input type="url" id="zoomLink" class="form-input" placeholder="https://zoom.us/...">
      </div>
      <div class="form-group">
        <label class="form-label" for="meetingDetails">Meeting Details</label>
        <textarea id="meetingDetails" class="form-input" rows="4" placeholder="Agenda, goals, etc."></textarea>
      </div>
      <div class="form-group">
        <label class="form-label">Activity Queue</label>
        <div id="activityQueueSelector" style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;">
          ${ACTIVITY_QUEUE_ITEMS.map(item => `
            <label style="display:flex;align-items:center;gap:8px;padding:6px 0;">
              <input type="checkbox" class="activity-queue-checkbox" value="${item.id}">
              <span style="font-size:1.2rem;">${item.icon}</span>
              <span>${escapeHtml(item.label)}</span>
            </label>
          `).join('')}
        </div>
      </div>
      <button class="btn-primary" data-action="save-meeting">Save Meeting</button>
      <button class="btn-secondary" data-action="go-screen" data-screen="dashboard" style="margin-top:10px;">Cancel</button>
    </div>
  `;
}

function renderLoadSession() {
  // Placeholder: Replace with actual session loading logic
  return `
    <div class="header">
      <h1 class="logo">Load Saved Session</h1>
      <p class="tagline">Select a session to load</p>
    </div>
    <div class="form-container">
      <div class="form-group">
        <label class="form-label">Saved Sessions</label>
        <select id="savedSessions" class="form-input">
          <option value="">-- Select Session --</option>
          <option value="session1">Session 1 (Example)</option>
          <option value="session2">Session 2 (Example)</option>
        </select>
      </div>
      <button class="btn-primary" data-action="load-selected-session">Load Session</button>
      <button class="btn-secondary" data-action="go-screen" data-screen="dashboard" style="margin-top:10px;">Cancel</button>
    </div>
  `;
}
</script>
</body>
</html>
